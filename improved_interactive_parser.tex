\subsection{Interactive Parser}

The Interactive Parser extends the official Solidity grammar with specialized entry rules that accept isolated code fragments during incremental editing. Built on ANTLR4~\cite{antlr}, the parser introduces seven entry rules for partial Solidity constructs plus one dedicated rule for batch-annotation blocks. The Context Analyzer (§3.1) selects the appropriate entry rule based on the surrounding code context; this section focuses on the grammar extensions themselves.

Table~\ref{tab:interactive-rules} summarizes the seven entry rules that handle partial Solidity code. Each rule accepts zero or more constructs of a specific syntactic category, terminated by EOF. This allows developers to add code incrementally—one statement, one member, or one clause at a time—without requiring a complete, compilable program.

\begin{table}[t]
\centering
\caption{Interactive parser entry rules}
\label{tab:interactive-rules}
\small
\begin{tabular}{@{}lp{9cm}@{}}
\toprule
\textbf{Entry Rule} & \textbf{Purpose} \\
\midrule
interactiveSourceUnit & Top-level declarations: functions, contracts, interfaces, libraries, state variables, pragmas, imports \\
interactiveEnumUnit & Enum member items added after the enum shell is defined \\
interactiveStructUnit & Struct member declarations added after the struct shell is defined \\
interactiveBlockUnit & Statements and control-flow skeletons inside function bodies \\
interactiveDoWhileUnit & The while tail of a do-while loop \\
interactiveIfElseUnit & else or else-if branches following an if statement \\
interactiveCatchClauseUnit & catch clauses following a try statement \\
\bottomrule
\end{tabular}
\end{table}

To support incremental construction of control structures, the grammar defines skeleton rules that accept headers with empty bodies. For instance, interactiveIfStatement matches an if-condition with an empty body, allowing the CFG builder to immediately construct control-flow edges even when the then-branch is not yet written. Similarly, interactiveForStatement, interactiveWhileStatement, interactiveTryStatement, and interactiveCatchClause all produce skeletal AST nodes with empty statement blocks. As developers fill in the body line by line, interactiveBlockUnit parses each new statement and the CFG builder inserts corresponding nodes into the control-flow graph.

Consider the burn function from Listing~\ref{lst:grammar-min}. When the developer types the function header, the Context Analyzer detects a top-level context and invokes interactiveSourceUnit, which matches interactiveFunctionElement. This creates a function node with an empty body, enabling the CFG builder to initialize the function's entry and exit nodes. As statements are added, the Context Analyzer selects interactiveBlockUnit, which accepts both simple statements (variable declarations, assignments) and control-flow skeletons. When an if-skeleton is encountered, interactiveIfStatement creates a condition node with an empty then-branch in the CFG. Later, if an else-branch is added, the Context Analyzer invokes interactiveIfElseUnit to attach an empty else-branch to the preceding if-node.

The debugUnit rule parses batch-annotation lines that specify initial abstract values for variables, enabling symbolic input scenarios without contract deployment. The grammar defines three annotation types:
\begin{itemize}[leftmargin=1.5em, itemsep=2pt]
  \item GlobalVar assigns values to global variables such as msg.sender or block.timestamp
  \item StateVar assigns values to contract state variables, supporting nested access patterns like balances[msg.sender] or user.balance
  \item LocalVar assigns values to function parameters and local variables
\end{itemize}

Each annotation accepts an L-value and a value specification. Supported value formats include integer intervals, symbolic addresses, boolean values, and symbolic placeholders for bytes and strings. The parser validates type compatibility and range bounds at parse time, warning developers if annotated values are incompatible with declared types. The Snapshot Manager (§3.4.3) consumes these annotations to overlay the initial abstract environment before function reinterpretation.

Complete grammar specifications, including all production rules and value formats for annotations, appear in Appendix~\ref{appendix:interactive-grammar}.
