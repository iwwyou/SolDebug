% Pass options to packages before documentclass to avoid option clash
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{colorlinks=true,linkcolor=blue,urlcolor=blue,citecolor=black}{hyperref}

\documentclass[pdflatex,sn-basic]{sn-jnl}% Basic style with author-year citations

% Korean language support
\usepackage[utf8]{inputenc}
%\usepackage{kotex}  % Commented out - package not found

% Math packages first
\usepackage{amsmath}%
\usepackage{amssymb}%
\usepackage{amsfonts}%
\usepackage{amsthm}%
\usepackage{amsopn}%
\usepackage{amstext}%
\usepackage{mathrsfs}%
\usepackage{stmaryrd}% For llbracket, rrbracket

% Graphics and tables
\usepackage{graphicx}%
\DeclareGraphicsExtensions{.png,.pdf,.jpg}% PNG first, then PDF
\usepackage{subcaption}% For subfigure environment
\usepackage{caption}% For caption customization
\captionsetup{justification=raggedright, singlelinecheck=false}% Left-align all captions by default
\captionsetup[figure]{justification=centering, singlelinecheck=false}% Center-align figure captions
\usepackage{tikz}%
\usetikzlibrary{positioning,shapes,arrows.meta}%
\usepackage{multirow}%
\usepackage{booktabs}%
\usepackage{tabularx}
\usepackage{array}
\usepackage{pdflscape}% For landscape tables
\usepackage{arydshln}% For dashed lines in tables

% Algorithm packages
\usepackage{algorithm}%
\usepackage{algorithmicx}%
\usepackage{algpseudocode}%

% Other packages
\usepackage[title]{appendix}%
\usepackage{placeins}% For \FloatBarrier to control figure placement
\usepackage{float}% For [H] option to force exact placement
\usepackage{xcolor}%
\usepackage{textcomp}%
% \usepackage{manyfoot}% Package not available in MiKTeX
\usepackage{listings}%
\usepackage{comment}
\usepackage{enumitem}% For list spacing control
\newcolumntype{L}{>{\raggedright\arraybackslash}X}

% Define Solidity language for listings
\lstdefinelanguage{Solidity}{
  keywords={contract, function, modifier, public, private, external, internal, view, pure, payable, returns, return, if, else, for, while, require, assert, mapping, address, uint256, uint, bool, string, memory, storage, calldata, event, emit, struct, enum, constructor, msg, this, new, delete, break, continue, throw, revert},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={true, false, null, this, new},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\theoremstyle{thmstyleone}%
\newtheorem{theorem}{Theorem}%  meant for continuous numbers
\newtheorem{proposition}[theorem]{Proposition}%
\theoremstyle{thmstyletwo}%
\newtheorem{example}{Example}%
\newtheorem{remark}{Remark}%

\theoremstyle{thmstylethree}%
\newtheorem{definition}{Definition}%

\raggedbottom

% Using author-year style to match submission guidelines
\bibpunct{(}{)}{;}{a}{,}{ } % a = author-year citations

% URL breaking settings (hyperref and url already loaded by sn-jnl.cls)
\Urlmuskip=0mu plus 1mu
\def\UrlBreaks{\do\/\do-\do\_\do\.\do\?\do\&}

\makeatletter
\renewcommand\@biblabel[1]{} % Remove numeric labels like [1]
\makeatother
\setlength{\bibsep}{0.2em}   % Space between bibliography items
\setlength{\bibhang}{2em}

% Custom math commands
\newcommand{\Abort}{\mathsf{Abort}}
\newcommand{\Norm}{\mathsf{Norm}}
\newcommand{\Ret}{\mathsf{Ret}}
\newcommand{\Env}{\mathit{Env}}

\begin{document}

\title[Article Title]{SolQDebug: Debug Solidity Quickly for Interactive Immediacy in Smart Contract
Development}

\author[1]{\fnm{Inseong} \sur{Jeon}}\email{iwwyou@korea.ac.kr}

\author[1]{\fnm{Sundeuk} \sur{Kim}}\email{sd\_kim@korea.ac.kr}

\author[1]{\fnm{Hyunwoo} \sur{Kim}}\email{khw0809@korea.ac.kr}

\author*[1]{\fnm{Hoh Peter} \sur{In}}\email{hoh\_in@korea.ac.kr}

\affil*[1]{\orgdiv{Department of Computer Science}, \orgname{Korea University},
\orgaddress{\street{145, Anam-ro}, \city{Seonbuk-gu}, \postcode{02841}, \state{Seoul},
\country{Republic of Korea}}}


\abstract{As Solidity becomes the dominant language for blockchain smart contracts,
    efficient debugging grows increasingly critical. However, current Solidity debugging
    remains inefficient: developers must compile, deploy, set up transactions, and trace bytecode execution step by step. This process is too slow for practical use.
    To address this challenge, this paper presented \textsc{SolQDebug},
    the first edit-time debugging assistant for Solidity designed for interactive analysis within a single contract/transaction context,
    providing abstract value summaries with millisecond feedback directly on source code.
    Developers specify symbolic interval inputs through annotations and compare them against abstract interpretation results,
    thereby capturing multiple input scenarios over various execution paths in a single analysis.
    \textsc{SolQDebug} was evaluated on 30 real-world functions from DAppSCAN, achieving millisecond-scale feedback during code editing.
    This paper also synthesized experimental observations on annotation patterns for arithmetic operations and loop constructs into practical guidelines.
    These results demonstrated that \textsc{SolQDebug} serves as an effective edit-time debugging assistant for Solidity development.}


\keywords{Smart Contract Development, Solidity, Debugging, Abstract Interpretation, Incremental Analysis}

\maketitle

\section{Introduction}\label{sec1}

    Blockchain technology has evolved from a simple cryptocurrency platform into a comprehensive ecosystem for decentralized applications.
    At the center of this evolution, Ethereum ranks second in market capitalization at over \$460 billion~\citep{coinmarketcap}.
    This ecosystem is powered by smart contracts written primarily in Solidity~\citep{solidity}, the dominant language for contract development.
    As these contracts grow more complex and handle increasing value, ensuring their correctness becomes critical.
    This is especially critical because once deployed to the blockchain, contracts are immutable and cannot be easily fixed.
    Recently, many developers rely on large language models (LLMs) such as ChatGPT~\citep{gpt} or Llama~\citep{llama} for code generation assistance.
    However, these tools cannot provide formal correctness guarantees.
    Therefore, developers must still rigorously understand program behavior at the statement level during editing.

    Unfortunately, the debugging workflow for Solidity lacks the maturity of traditional programming environments.
    Even a single inspection requires full compilation, deployment, manual state initialization, and manual bytecode-level tracing.
    Moreover, once a transaction modifies contract state, reverting to previous conditions requires costly redeployment or manual reconstruction, making iterative debugging impractical.
    Tools like Remix IDE~\citep{remix}, Hardhat~\citep{hardhat}, and Foundry Forge~\citep{forge} suffer from these fundamental limitations.
    A prior study found that 88.8\% of Solidity developers described debugging as painful, with 69\% attributing this pain to the absence of interactive source-level tooling~\citep{interview}.
    To the best of our knowledge, no existing research or tooling provides interactive feedback during Solidity code editing, a gap that this paper aims to fill.
    
    This paper presented \textsc{SolQDebug}, an edit-time debugging assistant for Solidity designed for interactive analysis within a single contract/transaction context,
    powered by abstract interpretation (AI) with interval domain.
    Unlike conventional step-through debuggers that require compilation and deployment,
    \textsc{SolQDebug} provided abstract value summaries as developers type, enabling exploration of function behavior at the statement level.
    To achieve this goal, \textsc{SolQDebug} built on two core ideas.
    First, it provided incremental analysis through interactive parsing and incremental control flow graph (CFG) construction via line-to-node indexing.
    As developers type each statement, the system efficiently determines insertion sites and extends the CFG, recomputing abstract states only for affected program points.
    Second, it enabled annotation-guided abstract interpretation. Developers specify symbolic interval inputs through annotations,
    and the interpreter captures multiple input scenarios over various execution paths in a single analysis.

    To validate these design choices, \textsc{SolQDebug} was evaluated on 30 real-world functions from DAppSCAN~\citep{dappscan}.
    The evaluation demonstrated millisecond-scale responsiveness and examined how annotation structure
    affected precision across common smart contract patterns. The results also showed how annotation-guided analysis
    addressed the precision challenges typically encountered in loops.
    These findings were synthesized into practical guidelines for developers.

    This paper makes the following contributions:

    \begin{itemize}
      \item This work identified the main barriers to interactive Solidity debugging: temporal inefficiency and iterative inefficiency.
      \item An interactive parser with seven specialized entry rules and line-to-node indexing was designed that enables incremental CFG construction with efficient statement insertion during editing.
      \item An annotation-guided abstract interpreter was introduced that mitigates precision challenges in loop analysis while maintaining termination guarantees.
      \item \textsc{SolQDebug} was evaluated on 30 real-world functions from DAppSCAN, achieving millisecond-scale feedback latency. The experimental findings were synthesized into practical guidelines for annotation patterns in arithmetic operations and loop constructs.
    \end{itemize}

    The rest of this paper is organized as follows.
    Section 2 provides background on Solidity and the debugging challenge.
    Sections 3--5 cover the design of SolQDebug, evaluation results, and discussion with practical guidelines.
    Section 6 reviews related work, and Section 7 concludes.

\section{Background}\label{sect2}
    \subsection{Structure of Solidity Smart Contract}
\vspace{-1em}
\begin{figure}[!h]
\begin{lstlisting}[language=Solidity, numbers=left, basicstyle=\ttfamily\small]
contract Example {
    address public owner;
    uint256 public totalSupply = 1000;
    mapping(address => uint256) private balances;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }
    function burn(uint256 amount) public onlyOwner {
        uint256 bal = balances[msg.sender];
        uint256 delta;
        if (bal >= amount) {
            balances[msg.sender] = bal - amount;
            delta = amount;
        }
        else {
            delta = 0;
        }
        totalSupply -= delta;
    }
}
\end{lstlisting}
\caption{Minimal example used to illustrate grammar elements relevant to our analysis}
\label{fig:grammar-min}
\end{figure}

        Figure~\ref{fig:grammar-min} illustrates the key structural elements of a Solidity smart contract.
        At the top level, Solidity programs may declare contracts, interfaces, and libraries.
        A contract is composed of variables and functions.

        Variables are categorized by their scope and lifetime.
        Global variables such as \texttt{msg.sender} (appearing at line 7) and \texttt{block.timestamp} represent read-only EVM metadata provided implicitly by the runtime.
        State variables such as \texttt{owner}, \texttt{totalSupply}, and \texttt{balances} (lines 2--4) persist across transactions and provide the contract's permanent storage.
        Local variables such as \texttt{bal} and \texttt{delta} (lines 12--13) are scoped to a single function call and do not persist beyond execution.

        Functions consist of statements such as assignments, conditionals (\texttt{if}/\texttt{else}), and loops (\texttt{while}/\texttt{for}).
        The \texttt{burn} function (lines 10--21) illustrates this structure.
        Solidity defines several function types, including \texttt{function}, \texttt{constructor}, \texttt{fallback}, \texttt{receive}, and \texttt{modifier}.
        Among these, modifiers provide reusable precondition checks.
        The \texttt{onlyOwner} modifier (lines 6--9) verifies that \texttt{msg.sender} equals \texttt{owner} before executing the function body.
        The placeholder underscore at line 8 marks where the original function body is inserted when the modifier is applied.

    \subsection{Solidity Execution Model and Debugging Workflow}
        Unlike traditional programs, Solidity contracts execute in a state-based environment where state modifications are irreversible.
        To debug Solidity code, developers must follow a multi-stage workflow as described in Steps 1--4.

        \smallskip
        \noindent\textbf{Step 1: Compile.}
        Figure~\ref{fig:step-compile} shows the compilation step in Remix IDE, where the contract source code is compiled into EVM bytecode.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.9\columnwidth,height=0.35\textheight, keepaspectratio]{Fig2.pdf}
  \caption{Traditional Solidity debugging workflow: Compile step}
  \label{fig:step-compile}
\end{figure}
\FloatBarrier

        \smallskip
        \noindent\textbf{Step 2: Deploy.}
        Figure~\ref{fig:step-deploy} illustrates selecting the target contract and deploying it.
        Deployment is a one-time transaction that stores compiled bytecode on-chain and invokes the constructor.
        Once deployed, the bytecode becomes immutable.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.9\columnwidth,height=0.3\textheight,keepaspectratio]{Fig3.pdf}
  \caption{Traditional Solidity debugging workflow: Deploy contract}
  \label{fig:step-deploy}
\end{figure}
\FloatBarrier

        \smallskip
        \noindent\textbf{Step 3: Initialize State and Execute.}
        Figure~\ref{fig:step-init} shows entering parameters and executing the target function for debugging.
        Before invoking the target function, developers must first execute setup functions
        to initialize the contract state and satisfy conditions enforced by \texttt{require} statements.
        Once the state is prepared, the target function is executed by clicking the transact button.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Fig4.pdf}
  \caption{Traditional Solidity debugging workflow: Initialize state and execute target function}
  \label{fig:step-init}
\end{figure}
\FloatBarrier

        \smallskip
        \noindent\textbf{Step 4: Debug.}
        Figure~\ref{fig:step-debug} shows clicking the debug button and stepping through bytecode instructions.
        Once the target function is executed, its execution is traced step by step at the bytecode level.

\begin{figure}[!h]
  \centering
  \includegraphics[width=1.01\columnwidth, keepaspectratio]{Fig5.pdf}
  \caption{Traditional Solidity debugging workflow: Bytecode-level debugging}
  \label{fig:step-debug}
\end{figure}
\FloatBarrier

        This debugging workflow introduces significant overhead that the following subsection analyzes in detail.

    \subsection{Two Sources of Inefficiency in Solidity Debugging}
        \smallskip
        \noindent\textbf{(1) Environmental disconnect between editor and execution engine causes temporal inefficiency.}
        Unlike conventional IDEs such as PyCharm~\citep{pycharm} or Visual Studio~\citep{visual},
        where the source editor and execution engine run in the same process,
        Solidity development involves external coordination with a blockchain node at every stage.
        The multi-stage workflow described in the previous subsection introduces several seconds to minutes of latency per iteration,
        preventing the immediate feedback that developers expect when writing and testing code.

        Given this workflow overhead, developers often rely on \texttt{emit} logs or event outputs to observe intermediate values.
        However, such instrumentation provides only runtime snapshots of a single execution.
        Moreover, changing what is being logged typically requires recompilation and redeployment, compounding latency and disrupting iteration.
        The final stage, stepping through raw EVM opcodes, is particularly slow because each source statement maps to multiple bytecode instructions.

        \smallskip
        \noindent\textbf{(2) Architectural limitations of EVM cause iterative inefficiency.}
        The EVM's state-based execution model makes state modifications irreversible.
        This constraint fundamentally conflicts with iterative debugging,
        where developers need to repeatedly execute the same function under varying conditions to understand control-flow behavior.

        Additionally, if a function includes conditional guards that depend on the current state such as account balances or counters,
        then any debugging session must first ensure that those conditions are satisfied.
        For example, consider a function that enforces a check on \texttt{\_balances[account]}.
        Developers must manually assign a sufficient balance before they can observe the downstream effects on \texttt{\_totalSupply}.
        Without such setup, the function exits early, preventing inspection of the intended execution path.

        In short, these constraints make repeated debugging iterations costly and fragile.
        According to a developer study~\citep{interview}, 88.8\% of Solidity practitioners reported frustration with current debugging workflows,
        with 69\% attributing this to the lack of interactive, state-aware tooling.

    \subsection{Proposed Approach Overview}

        \textsc{SolQDebug} addresses these two inefficiencies through an integrated design.
        Rather than independent optimizations, the two components jointly constitute an edit-time debugging assistant.
        Incremental analysis enables immediate feedback during editing, which defines the interactive aspect.
        Annotations provide input specification, which is essential for observing how inputs affect program behavior.

        \smallskip
        \noindent\textbf{(1) Incremental analysis to address temporal inefficiency.}
        The traditional debugging workflow requires compilation, deployment, transaction-based state setup, and bytecode tracing.
        Each of these stages incurs significant latency.
        \textsc{SolQDebug} replaces this round trip by performing both parsing and abstract interpretation directly inside the Solidity Editor.
        To support incremental editing, the Solidity grammar was extended with interactive parsing rules tailored for isolated statements.
        When the developer types or edits code, only the affected region is reparsed incrementally.

        Each parsed statement is inserted into an incremental CFG, and abstract interpretation resumes from the edit point.
        Among various abstract domains, the interval domain was chosen.
        It guarantees termination through widening and produces explainable results as variable ranges.
        These properties enable immediate feedback without compilation or chain interaction.

        \smallskip
        \noindent\textbf{(2) Annotation-guided interpretation to address iterative inefficiency.}
        The EVM does not support reverting to a prior state without redeploying the contract or replaying transactions.
        Both approaches disrupt iteration. \textsc{SolQDebug} introduces batch annotations, enabling developers to vary inputs or contract state to observe control-flow outcomes.
        Rather than reconstructing such conditions through on-chain transactions, developers can write annotations at the top of the function to define symbolic interval inputs.
        These inputs are injected before analysis begins and rolled back afterward, ensuring test-case isolation.

        This approach brings the debugging workflow closer to the source by making state manipulation explicit and reproducible within the code itself.
        Developers can explore alternative execution paths by editing annotations alone without modifying the contract logic or incurring compilation and deployment overhead.
        It effectively decouples symbolic interval input configuration from the analysis cycle while preserving the intuitive debugging process developers already follow.

\begin{figure*}[t]
  \centering
  \includegraphics[
    width=0.95\textwidth,
    height=0.35\textheight,
    keepaspectratio
  ]{Fig6.pdf}
  \vspace{0.3cm}
  \caption{\textsc{SolQDebug} architecture}
  \label{fig:solqdebug-arch}
\end{figure*}

\section{The design of SolQDebug}
    \textsc{SolQDebug} is designed to analyze single-contract, single-transaction Solidity functions
    through incremental statement-by-statement processing. As developers write code,
    the system maintains an evolving abstract interpretation of the program, enabling
    immediate feedback on variable values and potential errors without requiring compilation or deployment.
    The following subsections detail the architecture (\S3.1), provide a running example (\S3.2),
    and explain the core mechanisms for parsing (\S3.3) and incremental analysis (\S3.4).

    \subsection{System Architecture}
        Figure~\ref{fig:solqdebug-arch} illustrates the overall architecture of \textsc{SolQDebug}.
        The system accepts either single Solidity statements or batch debug annotations as input,
        processing them through two main modules before producing line-level output:

        \smallskip
        \noindent\textbf{(1) Parsing Module.}
        Each input passes through the \texttt{Context Analyzer}. For source code fragments,
        it identifies existing code structures when needed
        (e.g., an \texttt{if} statement for an \texttt{else} branch).
        For debug annotations, it identifies the target function and extracts its context.
        The \texttt{Interactive Parser}, built on ANTLR~\citep{antlr}, applies an extended grammar with seven specialized
        entry rules that enable parsing of partial constructs. To ensure correctness,
        the system performs syntactic recovery to reconstruct complete source from partial fragments and
        validates it using the official Solidity compiler before proceeding to analysis, ensuring
        semantic consistency and rejecting malformed input early.

        \smallskip
        \noindent\textbf{(2) Analysis Module.}
        The Analysis Module operates through three coordinated components. The \texttt{Incremental CFG
        Builder} maintains a control-flow graph that supports structural updates as statements are added,
        creating nodes and rewiring edges to reflect the evolving structure. The \texttt{Abstract Interpreter}
        analyzes the updated CFG incrementally, reusing previous results and recomputing
        abstract values only for affected program points. The \texttt{Snapshot Manager} preserves
        and restores abstract memory states, ensuring that debug annotations can be modified
        and re-executed without side effects from previous runs.

        \smallskip
        \noindent\textbf{Output.}
        Following analysis, \textsc{SolQDebug} produces a summary showing computed intervals at program points
        where values are defined, assigned, returned, or change through loop iterations by comparing pre-loop and post-loop abstract states.
        All outputs are mapped to their corresponding source line numbers, enabling rapid feedback as developers write and modify code.
    
    \subsection{Running Example}
\begin{table}[t!]
  \caption{Incremental inputs for the running example}
  \label{tab:input_code}
  \centering
  \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.05}
  \ttfamily\footnotesize
  \begin{tabularx}{\columnwidth}{@{}c c X@{}}
    \toprule
    \textbf{Step} & \textbf{Lines of Input Fragment} & \textbf{Fragment} \\
    \midrule
    1 & 11--12 &
      \begin{tabular}[t]{@{}l@{}}
        function burn(uint256 amount) public onlyOwner \{\\
        \}
      \end{tabular} \\
    2 & 12 & uint256 bal = balances[msg.sender]; \\
    3 & 13 & uint256 delta; \\
    4 & 14--15 &
      \begin{tabular}[t]{@{}l@{}}
        if (bal >= amount) \{\\
        \}
      \end{tabular} \\
    5 & 15 & balances[msg.sender] = bal - amount; \\
    6 & 16 & delta = amount; \\
    7 & 18--19 &
      \begin{tabular}[t]{@{}l@{}}
        else \{\\
        \}
      \end{tabular} \\
    8 & 19 & delta = 0; \\
    9 & 21 & totalSupply -= delta; // new input \\
    \bottomrule
  \end{tabularx}
  \rmfamily
\end{table}

    To illustrate how the proposed architecture functions in practice, we presented a concrete example using the \texttt{burn} function from Figure~\ref{fig:grammar-min}.
    As the developer incrementally constructs this function, the system (1) parses each input fragment, (2) updates the control-flow graph, and (3) performs abstract interpretation to compute variable intervals.
    Additionally, when batch debug annotations are present, the system re-analyzes the function using the annotated symbolic interval inputs as starting points.
    This example demonstrates these two key analysis modes: incremental source code analysis (\S{}3.2.1) and batch annotation analysis (\S{}3.2.2).

        \subsubsection{Incremental Source Code Analysis}
\begin{figure*}[t!]
  \centering
  \begin{tikzpicture}[scale=0.85, transform shape,
    node distance=1.5cm and 2.5cm,
    block/.style={rectangle, draw, thick, minimum width=3cm, minimum height=1cm, align=center, font=\footnotesize},
    cond/.style={diamond, draw, thick, aspect=2, minimum width=2cm, minimum height=1cm, align=center, font=\footnotesize},
    join/.style={rectangle, draw, thick, fill=yellow!20, minimum width=2.5cm, minimum height=0.6cm, align=center, font=\footnotesize},
    empty/.style={circle, draw, thick, minimum size=0.8cm, font=\large}
  ]

  % Entry and declarations
  \node[block] (entry) {ENTRY};
  \node[block, below=1cm of entry] (decl) {... declarations ...\\(Steps 2--3)\\env: \{bal: $\top$, delta: $\top$\}};

  % Condition node
  \node[cond, below=1.2cm of decl] (cond) {$bal \geq amount$};

  % Branch paths (simplified)
  \node[block, below left=1.5cm and 2cm of cond] (true) {... intermediate ...\\(Steps 5--6)};
  \node[block, below right=1.5cm and 2cm of cond] (false) {... intermediate ...\\(Step 8)};

  % Leaf nodes
  \node[block, below=1cm of true] (leaf_t) {[Leaf T]\\delta = amount\\env: \{bal:$\top$,\\delta:$\top$\}};
  \node[block, below=1cm of false] (leaf_f) {[Leaf F]\\delta = 0\\env: \{bal:$\top$,\\delta:[0,0]\}};

  % Join point
  \node[block, below=2cm of cond, yshift=-2.5cm] (join) {$\sqcup$ Join Node\\env: \{bal:$\top$,\\delta:$\top$\}};

  % New node with Step 9
  \node[block, below=1cm of join, fill=green!15] (step9) {[New Node]\\totalSupply -= delta\\env: \{totalSupply:$\top$\}};

  % Exit
  \node[block, below=1cm of step9] (exit) {EXIT};

  % Edges
  \draw[->, thick] (entry) -- (decl);
  \draw[->, thick] (decl) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {True} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {False} (false);
  \draw[->, thick] (true) -- (leaf_t);
  \draw[->, thick] (false) -- (leaf_f);
  \draw[->, thick] (leaf_t) -| (join);
  \draw[->, thick] (leaf_f) -| (join);
  \draw[->, thick] (join) -- node[right] {Step 9 inserted} (step9);
  \draw[->, thick] (step9) -- (exit);

  \end{tikzpicture}
  \caption{CFG structure showing Step 9 insertion. Each statement occupies a separate basic node; intermediate nodes along each branch are omitted, showing only the leaf nodes before the join point. The join point node computes the least upper bound of environments from both branches}
  \label{fig:solqdebug-cfg}
\end{figure*}

Table~\ref{tab:input_code} shows how the developer incrementally constructs the \texttt{burn}
function through nine distinct input steps, each introducing a new code fragment.

\textsc{SolQDebug} accepts two kinds of code fragments as input:

\begin{itemize}
  \item \textbf{Block fragment:} Includes contract and function definitions and control-flow constructs (if/else blocks, while loops).
        When the developer types an opening \texttt{\{}, most editors auto-insert the closing \texttt{\}},
        so the complete block arrives at once
        (e.g., Steps 1, 4, and 7 in Table~\ref{tab:input_code}).

  \item \textbf{Statement fragment:} Includes declarations, assignments, and expressions that
        end with semicolons. Each statement arrives individually as the developer completes typing,
        triggering immediate parsing and analysis
        (e.g., Steps 2, 3, 5, 6, 8, and 9 in Table~\ref{tab:input_code}).
\end{itemize}

As the developer types each fragment, \textsc{SolQDebug} incrementally extends the CFG
and recomputes abstract values only for affected program points.
Figure~\ref{fig:solqdebug-cfg} visualizes the CFG structure after Steps 1--8 have been integrated.
To illustrate incremental analysis, we focus on Step~9 (\texttt{totalSupply -= delta;}).
By this point, Steps 1--8 have been analyzed, and their results are already in the CFG.
When Step~9 arrives, it processes the statement as follows:

\begin{enumerate}
  \item The \texttt{Interactive Parser} recognizes \texttt{totalSupply -= delta;} as an assignment.
  \item The \texttt{Incremental CFG Builder} determines the insertion point by examining the edit context and existing CFG.
        In this case, the insertion point is after the join node that merges the if/else branches.
  \item A new node is created for the assignment, and edges are rewired: the join node now
        flows into this new node, which in turn connects to the exit.
  \item The new node receives the environment from the join node, which holds the least upper
        bound (\(\sqcup\)) of environments from both branches.
  \item The \texttt{Abstract Interpreter} performs worklist-based reinterpretation, propagating the updated
        environment from the newly inserted node to all affected nodes in the CFG.
\end{enumerate}

This reinterpretation ensures soundness by propagating each edit's effects to all
affected nodes. Subsequent inputs can then safely reuse the computed abstract
values without re-analyzing the entire program.

        \subsubsection{Batch Annotation Analysis}

\begin{figure}[t]
\begin{lstlisting}[language=Solidity, numbers=left, basicstyle=\ttfamily\small]
uint256 public totalSupply = 1000;

function burn(uint256 amount) public onlyOwner {
    // @Debugging BEGIN
    // @StateVar balances[msg.sender] = [100,200]
    // @LocalVar amount = [50,70]
    // @Debugging END
    uint256 bal = balances[msg.sender];
    uint256 delta;
    if (bal >= amount) {
        balances[msg.sender] = bal - amount;
        delta = amount;
    }
    else {
        delta = 0;
    }
    totalSupply -= delta;
}
\end{lstlisting}
\caption{Burn function with batch annotations}
\label{lst:grammar-batch}
\end{figure}

While incremental analysis supports the edit-test cycle, developers often need
to explore how their program behaves under different testing scenarios.
Batch annotations enable this by letting developers specify test inputs declaratively and
obtain line-level results in a single run.

Figure~\ref{lst:grammar-batch} shows the \texttt{burn} function with batch annotations.
        Annotation blocks are enclosed by \verb|// @Debugging BEGIN| and \verb|// @Debugging END|.
        Each annotation line specifies a variable type (\texttt{@StateVar} for state variables,
        \texttt{@LocalVar} for local variables) and assigns a symbolic interval input, supporting both
        simple variables and nested accesses like \texttt{balances[msg.sender]}.

In this example, we annotate \texttt{balances[msg.sender]} with the interval \([100,200]\)
        and \texttt{amount} with \([50,70]\) to explore how the \texttt{burn} function behaves
        under different balance and amount scenarios. The analysis propagates these intervals through
        the conditional branches, computing \texttt{delta} as \([0,150]\) at the join point and
        reducing \texttt{totalSupply} from \([1000,1000]\) to \([850,1000]\).

        When \textsc{SolQDebug} processes a batch annotation block, it follows this pipeline:

\begin{enumerate}
  \item \textbf{Parse and validate.} Each annotation line is parsed, type-checked, and converted
        to the corresponding abstract domain (e.g., intervals for integers).
  \item \textbf{Save state and overlay.} The unannotated abstract memory is saved, and the annotated
        values replace it for the analysis run.
  \item \textbf{Single-pass analysis.} \textsc{SolQDebug} re-analyzes the pre-built CFG with
        the annotated environment.
  \item \textbf{Restore previous state.} After analysis, the unannotated abstract memory is restored.
\end{enumerate}

Details of these mechanisms appear in \S{}3.3--\S{}3.4.

\subsection{Interactive Parser}

The \texttt{Interactive Parser} extends the official Solidity language grammar~\citep{solgram} with specialized entry rules
that accept partial code fragments during incremental editing.
The parser defines eight specialized entry rules: seven for incremental code edits
and one for batch annotations.

\begin{table}[t]
\centering
\caption{Interactive parser entry rules}
\label{tab:interactive-rules}
\small
\begin{tabular}{@{}c|lp{8cm}@{}}
\toprule
\textbf{Type} & \textbf{Entry Rule} & \textbf{Purpose} \\
\midrule
\multirow{2}{*}[-10pt]{Primary} & interactiveSourceUnit & Top-level declarations: functions, contracts, interfaces, libraries, state variables, pragmas, imports \\
& interactiveBlockUnit & Statements and control-flow skeletons inside function bodies \\
\midrule
\multirow{5}{*}[-8pt]{Continuation} & interactiveEnumUnit & Enum member items added after the enum shell is defined \\
& interactiveStructUnit & Struct member declarations added after the struct shell is defined \\
& interactiveDoWhileUnit & The while tail of a do-while loop \\
& interactiveIfElseUnit & else or else-if branches following an if statement \\
& interactiveCatchClauseUnit & catch clauses following a try statement \\
\bottomrule
\end{tabular}
\end{table}

Table~\ref{tab:interactive-rules} shows the seven rules for Solidity constructs, divided into two categories
that differ in how they interact with existing code:

\begin{itemize}
  \item \textbf{Primary rules} parse constructs that stand alone, requiring no context
        from previous edits.

  \item \textbf{Continuation rules} require context from existing structures. They explicitly
        depend on previously parsed constructs (e.g., \texttt{interactiveIfElseUnit} requires
        a preceding \texttt{if} statement to attach the \texttt{else} branch).
\end{itemize}

This distinction maintains syntactic validity during incremental edits.
\textsc{SolQDebug} validates that continuation rules have their required antecedent structure,
ensuring that the resulting program structure remains well-formed at each step.

For concreteness, we refer to the burn function in Table~\ref{tab:input_code}.
When the developer types the function definition (Step 1), it is parsed by \texttt{interactiveSourceUnit},
which creates a function with an empty body.
Subsequent inputs within the function body are parsed by \texttt{interactiveBlockUnit},
which handles both statement fragments (Steps 2, 3, 5, 6, 8) and block fragments (Step 4).
Step 7 illustrates how continuation rules work: the \texttt{else} block is parsed by
\texttt{interactiveIfElseUnit}, which depends on the preceding \texttt{if} from Step 4
(see Appendix~\ref{appendix:interactive-grammar}).

Beyond these seven interactive rules for Solidity constructs, the parser includes
a specialized \texttt{debugUnit} rule for batch annotations.
The grammar defines three annotation types:

\begin{itemize}
  \item \textbf{GlobalVar} assigns values to global variables such as msg.sender or block.timestamp
  \item \textbf{StateVar} assigns values to contract state variables, supporting nested access patterns like balances[msg.sender] or user.balance
  \item \textbf{LocalVar} assigns values to function parameters
\end{itemize}

The complete grammar specification appears in Appendix~\ref{appendix:interactive-grammar},
with the full ANTLR4 implementation available at~\citep{solqrule}.

    \subsection{Incremental CFG Construction and Abstract Interpretation}

Incremental CFG construction maintains a control-flow graph that evolves as developers insert new statements.
Rather than rebuilding from scratch, our approach modifies the graph in place.
We first describe the hierarchical organization of CFGs at the contract and function levels (\S3.4.1),
then explain how individual statements are incrementally spliced into the function-level CFG (\S3.4.2),
how the insertion site is determined (\S3.4.3), and how reinterpretation propagates abstract values
only through affected regions (\S3.4.4).

Our CFG consists of the following node types:
\begin{itemize}
  \item \texttt{entry node}: The unique entry point where execution begins. Contract-level CFGs have a contract entry, and function-level CFGs have a function entry.
  \item \texttt{state variable node}: A contract-level node that holds all state variable declarations. Since state variables have no branching logic, they are collected into a single node.
  \item \texttt{basic node}: Holds a single statement with one successor edge (e.g., declarations, assignments, \texttt{return}, \texttt{revert}).
  \item \texttt{condition node}: Represents branching constructs such as \texttt{if}, \texttt{else if}, \texttt{while}, \texttt{require}/\texttt{assert}, and \texttt{try}.
  \item \texttt{join node}: Merges control flow from multiple branches (e.g., \texttt{if join}, \texttt{else-if join}).
  \item \texttt{fixpoint evaluation node} (\(\phi\)): The loop join point used for widening and narrowing during fixpoint computation (\S3.4.3).
  \item \texttt{loop exit node}: The false branch that exits a loop when the loop condition fails.
  \item \texttt{return exit node}: A sink node that aggregates return values from all return statements. When a return statement is inserted, its containing node's outgoing edge is rewired to this node.
  \item \texttt{error exit node}: The function's unique exceptional exit (targets the exceptional path via \texttt{revert}, \texttt{require}, or \texttt{assert} failures).
  \item \texttt{exit node}: The unique normal exit point where execution terminates successfully. Contract-level CFGs have a contract exit, and function-level CFGs have a function exit.
\end{itemize}

\subsubsection{CFG Hierarchy}

\textsc{SolQDebug} organizes control flow at two levels.
At the contract level, a \texttt{ContractCFG} sequences state variable initializations, the constructor, and function definitions.
This ordering reflects how Solidity deploys contracts. State variables are initialized first, then the constructor executes and may modify those state variables.
Function definitions receive the environment that results from constructor execution.

At the function level, each \texttt{FunctionCFG} represents control flow starting from a function's entry point.
When a function declares modifiers, the function body is spliced into the modifier's control flow at the placeholder (\texttt{\_}) position.
When a function invokes another function, the callee's \texttt{FunctionCFG} is incorporated as part of the caller's control flow graph.
The complete CFG hierarchy structures are shown in Appendix~\ref{appendix:cfg-patterns}.

\subsubsection{Statement-Local, Incremental Construction}

Having described the hierarchical organization of CFGs, we now focus on how individual statements are incrementally spliced into the function-level CFG.
Each insertion operates at the \texttt{current node}, the insertion point for new statements.
The following statement types create their corresponding CFG structures:

\begin{itemize}
  \item \textbf{Simple statements} are spliced between the current node and its successors, creating a single \texttt{basic node}.
        This includes variable declarations, assignments, and function calls.
        The environment flows sequentially through the new node, updated by the statement's semantics (Figure~\ref{fig:new-simple-statement}).

  \item \textbf{If statement} creates a \texttt{condition node}, true/false \texttt{basic nodes}, and an \texttt{if join}.
        The environment propagates from the current node to the condition, then branches to the true/false arms with the environment pruned by the branch condition,
        and merges at the join node via the least upper bound operation (Figure~\ref{fig:new-if}).

  \item \textbf{Else-if clause} replaces the preceding false branch with a new \texttt{condition node} and its own join, which then connects to the outer \texttt{if join}.
        The environment flows through the else-if condition, branches to its true/false arms with pruning, merges at the else-if join,
        and continues to the outer join (Figure~\ref{fig:new-else-if}).

  \item \textbf{Else clause} replaces the false branch node of the preceding \texttt{if}/\texttt{else if} with a new else node, which connects to the \texttt{if join}.
        The environment is pruned by the negated condition and merges at the join (Figure~\ref{fig:new-else}).

  \item \textbf{While loop} creates a \texttt{fixpoint evaluation node} $\phi$, a \texttt{condition node}, a loop body node, and a \texttt{loop exit node}.
        The body connects back to $\phi$ for fixpoint iteration.
        The environment propagates through $\phi$ to the condition, then branches to the body or exit with the environment pruned by the loop condition,
        with the body flowing back to $\phi$ until a fixpoint is reached (Figure~\ref{fig:new-while}).

  \item \textbf{Break statement} is inserted in the loop body with its outgoing edge redirected to the \texttt{loop exit node} (Figure~\ref{fig:new-break}).

  \item \textbf{Continue statement} is inserted in the loop body with its outgoing edge redirected to the loop's $\phi$ node (Figure~\ref{fig:new-continue}).

  \item \textbf{Return statement} is inserted with its edge rewired to the function's unique \texttt{return exit node}, detaching original successors.
        The environment flows directly to the return exit node (Figure~\ref{fig:new-return}).

  \item \textbf{Require/assert statement} creates a \texttt{condition node} with the true edge connecting to the successor node and the false edge pointing to the \texttt{error exit node}.
        The true edge receives the environment pruned by the predicate, while the false edge leads to the error exit node (Figure~\ref{fig:new-require}).

  \item \textbf{Revert statement} is inserted into a \texttt{basic node} with its outgoing edge rewired to the \texttt{error exit node} (Figure~\ref{fig:new-revert}).
\end{itemize}

These construction patterns enable \textsc{SolQDebug} to build the CFG incrementally as the developer types each statement, with environment updates propagating only through affected nodes.
Representative CFG construction patterns are provided in Appendix~\ref{appendix:cfg-patterns}.
The complete implementation supports all Solidity statements except inline assembly~\citep{solqimpl}.

\subsubsection{Line-to-Node Indexing for Incremental Insertion}
\begin{table}[t!]
\centering
\caption{Line-to-node index mapping by statement type}
\label{tab:line-mapping}
\small
\begin{tabular}{@{}lll|lll@{}}
\toprule
\multicolumn{3}{c|}{\textbf{Simple Statements}} & \multicolumn{3}{c}{\textbf{Compound Statements}} \\
\textbf{Statement} & \textbf{Maps Start} & \textbf{Maps End} & \textbf{Statement} & \textbf{Maps Start} & \textbf{Maps End} \\
 & \textbf{Line To} & \textbf{Line To} &  & \textbf{Line To} & \textbf{Line To} \\
\midrule
\texttt{simple statement} & basic node & (none) & \texttt{if} & condition node & join node \\
 & & & \texttt{else if} & condition node & join node \\
\texttt{break} & basic node & (none) & \texttt{else} & else node & join node \\
\texttt{continue} & basic node & (none) & \texttt{while} & condition node & loop exit node \\
\texttt{return} & basic node & (none) & & & \\
\texttt{revert} & basic node & (none) & & & \\
\texttt{require/assert} & condition node & (none) & & & \\
\bottomrule
\end{tabular}
\end{table}

The key challenge in incremental CFG construction is determining where to insert each new node.
Traditional CFG construction processes complete programs sequentially, building the entire graph in a single pass.
In contrast, \textsc{SolQDebug} must handle partial code edits that specify only target line numbers.
Since CFG edges encode control flow rather than source positions, we cannot determine where an edit belongs without additional context.
To enable incremental insertion, we maintain a line-to-node index during construction. Table~\ref{tab:line-mapping} summarizes how statement types map lines to nodes.

\texttt{Simple statements} index only their start line.
Most statements map to a basic node, though return maps to a return node and require maps to a condition node.
Compound statements index both start and end lines.
Conditionals (\texttt{if} and \texttt{else if}) map their start line to a condition node and end line to a join node,
while \texttt{else} maps its start line to an else node and end line to the join node.
Loops (\texttt{while}) map their start line to a condition node and end line to an exit node.

This indexing scheme enables Algorithms~\ref{alg:get-branch-context} and~\ref{alg:get-insertion-site} to locate insertion sites efficiently.
These algorithms handle the representative statement types shown in Table~\ref{tab:line-mapping}.
Both algorithms rely solely on the line-to-node index without mutating the graph.

The choice between these algorithms depends on whether the statement can exist independently:
\begin{itemize}
  \item \textbf{Dependent contexts:} \texttt{else}/\texttt{else if} must attach to a preceding \texttt{if}/\texttt{else if} condition. Algorithm~\ref{alg:get-branch-context} traverses CFG predecessors to find the condition node.
  \item \textbf{Independent contexts:} Other statements can exist independently. Algorithm~\ref{alg:get-insertion-site} uses a successor-first strategy, leveraging the fact that successors are already inserted and have complete CFG structure.
\end{itemize}

\begin{algorithm}[!h]
\caption{Dependent-Context Insertion}
\label{alg:get-branch-context}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, line-to-node index $M$, current line $L$
\State \textbf{Output:} Condition node $c$
\Function{GetBranchContext}{$G, M, L$}
  \State $queue \gets \texttt{FindJoinNode}(M, L)$ \Comment{find join node at or before line $L$}
  \If{$queue=\emptyset$} \State \textbf{error} ``No join node found at or before line $L$'' \EndIf
  \State $visited \gets \emptyset$

  \While{$queue\neq\emptyset$} \Comment{BFS through predecessors}
    \State $n \gets \texttt{Dequeue}(queue)$
    \If{$n\in visited$} \textbf{continue} \EndIf
    \State $visited \gets visited\cup\{n\}$

    \If{$\texttt{IsCond}(G, n)$ \textbf{and} $\texttt{CondType}(n)\in\{\texttt{if},\texttt{else\_if}\}$}
      \State \Return $n$
    \EndIf

    \For{$p\in\texttt{Pred}(G, n)$}
      \If{$p\notin visited$} \State $\texttt{Enqueue}(queue,p)$ \EndIf
    \EndFor
  \EndWhile

  \State \textbf{error} ``No matching condition node found''
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:get-branch-context}: Dependent-Context Insertion.}
Dependent contexts (\texttt{else}/\texttt{else if}) cannot exist independently and must attach to a preceding
\texttt{if}/\texttt{else if} condition node. The algorithm proceeds as follows:
\begin{itemize}
  \item \textbf{Initialization (Lines 4--8):} Use the line-to-node index $M$ to retrieve the join node at or before line \(L\) and initialize the Breadth-First Search (BFS) queue. This node serves as the starting point for backward traversal to find the preceding conditional. If no node is found, the dependent context is invalid (Lines 5--7). Initialize the visited set to track explored nodes (Line 8).
  \item \textbf{BFS traversal (Lines 9--22):} Perform BFS over CFG predecessors to find the matching condition node of type \texttt{if} or \texttt{else\_if}. The BFS ensures finding the nearest preceding condition node.
  \item \textbf{Error handling (Line 23):} Report an error if no matching condition is found.
\end{itemize}

\begin{algorithm}[!h]
\caption{Independent-Context Insertion}
\label{alg:get-insertion-site}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, line-to-node index $M$, insertion position at line $L$
\State \textbf{Output:} Insertion-site node $A$
\Function{GetInsertionSite}{$G, M, L$}
  \State $s \gets \texttt{FindPostNode}(M, L)$ \Comment{find first node after line $L$}

  \If{$\texttt{IsLoopExit}(G, s)$ \textbf{or} $\texttt{IsJoin}(G, s)$} \Comment{closing a loop or selection}
    \State $n \gets \texttt{FindPreviousNode}(M, L)$ \Comment{condition if exists, else last node}
    \If{$\texttt{IsCond}(G, n)$}
      \State \Return $\texttt{BranchBlock}(n,\mathsf{true})$ \Comment{insert in TRUE branch}
    \Else
      \State \Return $n$
    \EndIf

  \Else \Comment{basic successor}
    \State $pred \gets \texttt{Pred}(G, s)$
    \If{$|pred|=1$} \State \Return the unique element of $pred$
    \Else \State \textbf{error} ``Basic successor must have exactly 1 predecessor''
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:get-insertion-site}: Independent-Context Insertion.}
Independent contexts include statements other than \texttt{else}/\texttt{else if}.
For these contexts, a successor-first strategy is used.
This strategy works by identifying the post node (the node mapped after line $L$ in the index $M$) and determining the correct insertion point based on its CFG structure.
This approach handles all statement types uniformly:
\begin{itemize}
  \item \textbf{Find post node (Line 4):} Retrieve the first node after line \(L\) from the line-to-node index using \texttt{FindPostNode}(\(M, L\)).
  \item \textbf{Loop-exit/join case (Lines 5--11):} If the post node \(s\) is a loop-exit or join node, search backward using \texttt{FindPreviousNode}(\(M, L\)) to find the previous node. This returns a condition node if one exists (loop condition node or \texttt{if}). Otherwise, it returns the last node before \(L\).
    \begin{itemize}
      \item If it is a condition node, return its TRUE branch to place the new statement inside the construct (Line 8).
      \item Otherwise, return the node itself (Line 10).
    \end{itemize}
  \item \textbf{Basic post node (Lines 12--19):} Otherwise, \(s\) is a basic statement node (Line 12). Retrieve and verify the CFG predecessors to be exactly one (Lines 13--15). This invariant holds by construction: conditionals are created with their join nodes, and loops are created with their exit nodes. Any other count indicates a malformed CFG (Lines 16--18).
\end{itemize}

        \subsubsection{Abstract Interpretation for Incremental Analysis}\label{sec:impl}
\textsc{SolQDebug} provides rapid feedback on source code edits by propagating updates only along affected CFG paths, avoiding full re-analysis.
When the developer inserts statements, new nodes are spliced into the CFG. Incremental reinterpretation then propagates updates from these insertion points as seed nodes.
Debug annotations instead require full interpretation from the function entry node to ensure all inspection points receive complete abstract states.
Algorithm~\ref{alg:reinterpret} performs incremental interpretation by propagating abstract states through a worklist-based dataflow analysis.
When encountering loop condition nodes, it delegates to Algorithm~\ref{alg:fixpoint} for loop fixpoint computation.

\begin{algorithm}[t!]
\caption{Incremental Interpretation}
\label{alg:reinterpret}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, seed set $S$
\State \textbf{Output:} Environments updated along forward-reachable paths from $S$
\Function{IncrementalInterpretation}{$G, S$}
  \State $wl\gets\langle\rangle$; \quad $inq\gets\emptyset$; \quad $out\gets$ output map
  \ForAll{$s\in S$}
    \If{$\neg\texttt{IsSink}(G, s)\ \land\ s\notin inq$} \State $wl.\textsf{enqueue}(s)$; \quad $inq\gets inq\cup\{s\}$ \EndIf
  \EndFor

  \While{$wl\neq\langle\rangle$}
    \State $n \gets wl.\textsf{dequeue}()$; \quad $inq\gets inq\setminus\{n\}$
    \State $\hat{\sigma}_{\mathrm{in}}\gets \bigsqcup_{p\in\texttt{Pred}(G, n)} \texttt{PruneByCondition}(p,n)$

    \If{$\texttt{IsLoopHeader}(G, n)$}
       \State $exit \gets \texttt{Fixpoint}(G, n)$ \Comment{compute loop fixpoint (Algorithm~\ref{alg:fixpoint})}
       \ForAll{$s \in \texttt{Succ}(G, exit)$}
         \If{$\neg\texttt{IsSink}(G, s)\ \land\ s\notin inq$} \State $wl.\textsf{enqueue}(s)$; \quad $inq\gets inq\cup\{s\}$ \EndIf
       \EndFor
       \State \textbf{continue}
    \EndIf

    \State $\hat{\sigma}_{\mathrm{out}}\gets \texttt{Transfer}(n,\hat{\sigma}_{\mathrm{in}})$
    \If{$\hat{\sigma}_{\mathrm{out}}\neq out[n]$}
       \State $\Env(n)\gets \hat{\sigma}_{\mathrm{out}}$; \quad $out[n]\gets \hat{\sigma}_{\mathrm{out}}$
       \ForAll{$s \in \texttt{Succ}(G, n)$}
         \If{$\neg\texttt{IsSink}(G, s)\ \land\ s\notin inq$} \State $wl.\textsf{enqueue}(s)$; \quad $inq\gets inq\cup\{s\}$ \EndIf
       \EndFor
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:reinterpret}: Incremental Interpretation.}
\begin{itemize}
  \item \textbf{Worklist and output cache initialization (Line 4):} Initialize empty worklist $wl$, in-queue set $inq$ to track enqueued nodes, and output map $out$ to store previous node outputs for change detection.

  \item \textbf{Seed node initialization (Lines 5--9):} Enqueue all seed nodes $s \in S$, which mark insertion points for incremental edits or function entry for batch annotations. Sink nodes (\texttt{exit node}, \texttt{return exit node}, \texttt{error exit node}) with no successors are filtered out.

  \item \textbf{Worklist iteration (Lines 10--31):} Process nodes until the worklist is empty. For each dequeued node $n$:

  \item \textbf{Incoming environment computation (Lines 11--12):} For each predecessor $p$, use \texttt{PruneByCondition} to examine the edge from $p$ to $n$. If $p$ is a condition node, prune the predecessor's output environment based on the branch direction (true or false) to remove infeasible paths. For non-condition predecessors, no pruning is needed. At join nodes with two predecessors, merge the resulting states via $\sqcup$. Single-predecessor nodes receive the (possibly pruned) state directly as $\hat{\sigma}_{\mathrm{in}}$.

  \item \textbf{Loop condition node delegation (Lines 13--21):} When encountering a loop condition node, delegate to Algorithm~\ref{alg:fixpoint} to compute the loop fixpoint. After the fixpoint is reached, enqueue the loop-exit node's successors to continue analysis beyond the loop.

  \item \textbf{Transfer function (Line 22):} Apply the abstract transfer function to node $n$, computing output environment $\hat{\sigma}_{\mathrm{out}}$ by interpreting statements (assignments, calls, etc.) using interval arithmetic and domain operations.

  \item \textbf{Change detection and propagation (Lines 23--30):} Compare $\hat{\sigma}_{\mathrm{out}}$ with the previously stored output $out[n]$. If changed, update the node environment and stored output, then enqueue successors. Sink nodes (\texttt{exit node}, \texttt{return exit node}, \texttt{error exit node}) are not enqueued, so propagation terminates along exceptional paths such as \texttt{revert} or failed \texttt{require}/\texttt{assert}. This ensures fixpoint termination by stopping propagation when environments stabilize.
\end{itemize}

\begin{algorithm}[!h]
\caption{Loop Fixpoint with Adaptive Widening}
\label{alg:fixpoint}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, loop condition node $h$
\State \textbf{Output:} Loop exit node with stabilized environment
\Function{LoopFixpoint}{$G, h$}
  \State $L \gets \texttt{LoopNodes}(G, h)$; \quad $start \gets \bigsqcup\{\Env(p)\mid p\in\texttt{Pred}(G, h)\setminus L\}$
  \State $\tau \gets \texttt{EstimateIterations}(h, start)$ \Comment{annotation-aware threshold}
  \State $vis[\cdot]\gets 0$; \quad $in[h]\gets start$

  \State \textbf{// Widening phase}
  \State $wl\gets \langle h\rangle$
  \While{$wl\neq\langle\rangle$}
    \State $n\gets wl.\textsf{dequeue}()$; \quad $vis[n]\gets vis[n]+1$
    \If{$in[n] = \bot$} \Comment{compute input if not initialized}
       \State $in[n] \gets \bigsqcup_{p\in\texttt{Pred}(G, n)\cap L} \texttt{PruneByCondition}(p,n)$
    \EndIf
    \State $\hat{o}_{\text{raw}}\gets \texttt{Transfer}(n,in[n])$
    \If{$\texttt{IsFixpointEvalNode}(n)\ \land\ vis[n] > \tau$}
       \State $\hat{o}\gets \texttt{Widen}(out[n],\hat{o}_{\text{raw}})$ \Comment{widen at fixpoint eval node after $\tau$ visits}
    \Else \State $\hat{o}\gets out[n]\sqcup \hat{o}_{\text{raw}}$
    \EndIf

    \If{$\hat{o} = out[n]$} \State $out[n]\gets \hat{o}$; \textbf{ continue} \Comment{fixpoint reached, skip propagation}
    \EndIf

    \State $out[n]\gets \hat{o}$
    \ForAll{$s \in \texttt{Succ}(G, n) \cap L$}
      \State $wl.\textsf{enqueue}(s)$
    \EndFor
  \EndWhile

  \State \texttt{NarrowingPhase}($L$) \Comment{standard descending iteration}

  \State $exit \gets \texttt{FindLoopExit}(G, h)$
  \State $\Env(exit) \gets \bigsqcup_{p\in\texttt{Pred}(G, exit)} \texttt{PruneByCondition}(p, exit)$ \Comment{join with false-branch pruning}
  \State \Return $exit$
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:fixpoint}: Loop Fixpoint with Adaptive Widening.}
While Algorithm~\ref{alg:reinterpret} handles general incremental propagation,
loop analysis with the interval domain faces a well-known precision challenge.
To guarantee termination, widening operators must be applied after a bounded number of iterations,
often causing intervals to expand to $\top$ or $[0, \infty]$ even when the actual loop bounds are finite.
However, Solidity's properties create opportunities for mitigation.
Gas costs limit loop complexity, and loop conditions commonly depend on simple values
such as array lengths, mapping sizes, or bounded counters.

Algorithm~\ref{alg:fixpoint} computes loop fixpoints using annotation-aware adaptive widening to address this challenge.
The key innovation is that \texttt{EstimateIterations} analyzes loop conditions to compute an adaptive threshold $\tau$ that defers widening. When debug annotations provide precise interval bounds for condition operands such as array lengths or parameter values, the analyzer raises $\tau$ to delay widening and preserve precision. The fixpoint iteration terminates when all variables converge, meaning node outputs equal their previously stored values, ensuring soundness.

\begin{itemize}
  \item \textbf{Identify loop nodes and pre-loop environment (Line 4):} Collect all nodes within the loop body. Compute $start$ by joining environments from all loop-entry predecessors, specifically those from outside the loop rather than from within the loop body itself.

  \item \textbf{\texttt{EstimateIterations} (Line 5):} Evaluate both operands of the loop condition in the pre-loop environment $start$. For comparison operators ($<, \le, >, \ge$), compute adaptive threshold $\tau$ as follows:
  \begin{itemize}
    \item When both operands evaluate to concrete constant intervals, $\tau$ is computed as the difference between operand bounds. For example, given \texttt{i < array.length} where \texttt{i = [0,0]} and \texttt{array.length = [10,10]}, $\tau = 10 - 0 = 10$. The operands may be variables or complex expressions, but both must reduce to constant intervals through annotation-provided values.
    \item When either operand cannot be reduced to a constant interval, $\tau$ defaults to 1, allowing one iteration to initialize node environments before widening is applied.
  \end{itemize}

  \item \textbf{Initialization (Line 6):} Initialize visit counts $vis$ to track iterations and node input environments $in$, setting $in[h] \gets start$ for the loop condition node.

  \item \textbf{Widening phase (Lines 9--27):} Perform fixpoint iteration with worklist-based propagation. For each iteration:
  \begin{itemize}
    \item Dequeue node and increment visit count (Line 10); compute incoming environment if not initialized (Lines 11--13).
    \item Apply transfer function to compute raw output (Line 14).
    \item Apply adaptive widening (Lines 15--19): use widening operator if visit count exceeds $\tau$ (Line 16), otherwise use join (Line 18).
    \item Check for convergence (Lines 20--22): if output unchanged, skip propagation (Line 21); otherwise, store output (Line 23) and enqueue successors (Lines 24--26).
  \end{itemize}

  \item \textbf{Narrowing phase and exit node (Lines 28--31):} Apply standard narrowing using descending iteration with narrowing operator at fixpoint evaluation nodes to refine over-approximations from widening (Line 28). Then compute the exit node environment (Lines 29--30) by joining predecessor outputs where the loop condition node's false-branch is pruned by the negated loop condition. Return the exit node with its computed environment (Line 31).
\end{itemize}

\smallskip
\noindent\textbf{Abstract Interpretation Framework.}
Our approach builds upon abstract interpretation frameworks for Solidity smart contracts~\citep{flow,DBM}.
\textsc{SolQDebug} computes sound over-approximations of variable ranges using interval domains
for integer and boolean types ($\widehat{\mathbb{Z}}_N, \widehat{\mathbb{U}}_N$), set abstractions
for addresses, and on-demand materialization for composite types such as arrays, mappings, and structs.
Unlike prior work focusing on invariant generation~\citep{DBM} or information flow analysis~\citep{flow}, we target interactive debugging with incremental refinement.
The complete formal semantics (Tables~\ref{tab:conc-denot} and~\ref{tab:abs-denot}) are in Appendix~\ref{app:semantics}.

\FloatBarrier

% SECTION 3.5 MOVED TO APPENDIX A
% (Former subsection: Design of the Abstract Interpretation Framework for Solidity)
% CONTENT MOVED TO APPENDIX A

\section{Evaluation}
To evaluate the benefits of \textsc{SolQDebug} in real-world development scenarios,
we structure our empirical analysis around three key questions:

\begin{itemize}
  \item \textbf{RQ1 -- Responsiveness}:\;%
        How much does \textsc{SolQDebug} reduce debugging latency compared to Remix?

  \item \textbf{RQ2 -- Impact of Annotation Patterns on Precision}:\;%
        How should developers structure annotations to improve precision in
        arithmetic operations involving multiplication and division?

  \item \textbf{RQ3 -- Loops}:\;%
        How does \textsc{SolQDebug}'s analysis approach affect precision in loop structures?
\end{itemize}

To answer these questions, we conducted experiments under controlled conditions.

\subsection{Experimental Setup}
\textsc{SolQDebug} was evaluated on single-contract, single-transaction functions
to validate the contributions of incremental CFG construction and
annotation-guided abstract interpretation, with multi-contract analysis
as future work.

\smallskip
\noindent\textbf{Experimental Setting.}
The evaluation environment consists of an 11th Gen Intel\textregistered{} Core\texttrademark{}
i7-11390H CPU at 3.40GHz with 16.0~GB RAM, running Windows 10 (64-bit).
\textsc{SolQDebug} is implemented in Python~3.10 and operates directly on Solidity
source code without requiring compilation or deployment, using the ANTLR4-based
parser described in Section~3.

\smallskip
\noindent\textbf{Dataset Collection.}
The dataset was derived from DAppSCAN~\citep{dappscan}, a large-scale benchmark containing
3,344 Solidity contracts compiled with Solidity version 0.8.0 or later. To ensure representative
coverage across contract sizes, contracts smaller than 4~KB (2,142 samples) were first excluded,
which typically contain minimal logic unsuitable for debugging analysis. From the remaining
1,202 contracts, approximately 10\% were sampled from each of three size brackets:
\begin{itemize}
  \item 4--10~KB (735 contracts): 70 samples
  \item 11--20~KB (304 contracts): 30 samples
  \item Over 20~KB (163 contracts): 20 samples
\end{itemize}
\noindent From the 120 sampled contracts, functions were filtered based on four exclusion criteria reflecting scope limitations and analysis requirements:

\begin{table}[t]
\centering
\caption{Function filtering statistics across 120 benchmark contracts.}
\label{tab:filtering-stats}
\begin{tabular*}{\columnwidth}{@{\extracolsep{\fill}}lrr@{}}
\toprule
\textbf{Category} & \textbf{Functions} & \textbf{Ratio (\%)} \\
\midrule
Total functions extracted & 1,529 & 100.0 \\
\midrule
\multicolumn{3}{l}{\textit{Excluded by filtering criteria (in priority order):}} \\
\quad 1. External dependencies & 1,083 & 70.8 \\
\quad 2. Inline assembly & 1 & 0.1 \\
\quad 3. Data built-in functions & 21 & 1.4 \\
\quad 4. Trivial functions & 282 & 18.4 \\
\midrule
\textbf{Candidate functions} & \textbf{142} & \textbf{9.3} \\
\bottomrule
\end{tabular*}
\end{table}

\begin{enumerate}
  \item \textbf{External dependencies}---functions involving cross-contract interactions were excluded:
    \begin{itemize}
      \item External contract calls (e.g., \texttt{IERC20(token).transfer()})
      \item Library function calls via Solidity's \texttt{using} directive
      \item Low-level calls (\texttt{.delegatecall()}, \texttt{.staticcall()})
      \item Inherited parent contract dependencies
    \end{itemize}

  \item \textbf{Inline assembly}---functions containing EVM assembly blocks were excluded, as they bypass Solidity's type system and require specialized low-level analysis beyond the scope of source-level debugging.

  \item \textbf{Data built-in functions}---functions using Solidity's built-in data transformation operations were excluded. These operations are opaque to source-level analysis and their internal computations cannot be traced step-by-step:
    \begin{itemize}
      \item Cryptographic functions (\texttt{keccak256}, \texttt{sha256}) and ABI encoding/decoding (\texttt{abi.encode}, \texttt{abi.decode})
    \end{itemize}

  \item \textbf{Trivial functions}---functions with minimal logic that provide no meaningful debugging targets were excluded:
    \begin{itemize}
      \item Single-statement returns, assignments, or function calls (where the callee is within analysis scope)
      \item Functions with empty bodies
    \end{itemize}
\end{enumerate}

\noindent The hierarchical filtering ensures each function is counted in exactly one exclusion category. As shown in Table~\ref{tab:filtering-stats}, external dependencies dominate (70.8\%), reflecting the highly modular nature of modern DeFi contracts. After filtering, 142 candidate functions (9.3\%) remain suitable for debugging analysis.

\input{benchmark_table}

After applying these filters, representative functions were selected based on three dimensions of debugging complexity:
\begin{itemize}
  \item \textbf{Computational complexity}---complex arithmetic patterns with
        chained computations across multiple statements, making value ranges
        hard to predict manually.
  \item \textbf{Data structure complexity}---structs with multiple fields, nested
        mappings, dynamic arrays, and mapping-to-struct patterns.
  \item \textbf{Control flow complexity}---loops with varying termination conditions,
        nested conditionals, and modifier-based access control.
\end{itemize}
Based on these criteria, we selected 30 representative functions for evaluation from diverse DeFi scenarios including token transfers
with custom logic, staking/vesting mechanisms, liquidity pool operations, oracle
data processing, and marketplace transactions.
Table~\ref{tab:benchmark-dataset} lists all 30 benchmark contracts with their
source files, target functions, and line counts.

The following presents the findings for each research question.

\subsection{RQ1 - Responsiveness}
\noindent\textbf{Baseline Selection.}
RQ1 evaluates the reduction in debugging workflow latency, defined as the time required for developers to understand program behavior under specific input ranges.
While abstract interpretation techniques such as demanded summarization~\citep{daig} have been proposed for other languages,
these focus on optimizing static analysis pipelines rather than supporting interactive debugging.
Remix IDE, in contrast, provides debugging functionality for tracing execution flows with user-specified inputs, aligning with \textsc{SolQDebug}'s target task.
We therefore selected Remix as our baseline, as it is the only existing Solidity tool capable of performing the same debugging task.

\smallskip
\noindent\textbf{Measurement.}
To evaluate responsiveness, we measured debugging latency by recording the time to step through function execution line-by-line.
For Remix IDE, this corresponds to the duration from opening the debugger to stepping through the entire execution using the "step forward" button.
For \textsc{SolQDebug}, it represents the time from a code modification to the display of updated variable information.

Since Remix IDE lacks built-in automated benchmarking capabilities, we developed \texttt{remix\_benchmark}~\citep{remix_bench},
a Selenium~\citep{selenium}-based automation framework that programmatically controls the Remix web interface, automating compilation, deployment, and step-through debugging.
However, due to the prohibitive time cost of executing multiple transactions per function, Remix measurements were conducted only at $\Delta = 0$.
For larger test-case widths, latencies were estimated by linear extrapolation, as each additional input requires a separate transaction execution.

For \textsc{SolQDebug}, although designed for interactive use within a Solidity editor, all experiments simulate this behavior in a controlled scripting environment.
For each function, a sequence of incremental edits and annotations was reconstructed that mimic realistic developer activity.
These fragments are streamed into the interpreter to measure latency and interval growth under reproducible conditions.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{Fig9.pdf}
  \caption{Debugging latency comparison (5-run means).}
  \label{fig:rq1-responsiveness}
\end{figure}

\begin{table}[t]
\centering
\caption{Statistical comparison of debugging workflow latency between \textsc{SolQDebug} and Remix (test-case width $\Delta = 0$, 5-run means, $n=30$ contracts).}
\label{tab:statistical-comparison}
\begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}lcc@{}}
\toprule
\textbf{Metric} & \textbf{SolQDebug} & \textbf{Remix} \\
\midrule
Mean latency (s) & 0.24 & 54.62 \\
Median latency (s) & 0.09 & 51.68 \\
Std. deviation (s) & 0.42 & 25.53 \\
Range (s) & 0.02--1.88 & 25.6--128.7 \\
\midrule
\multicolumn{3}{@{}l}{\textbf{Statistical Test}} \\
\midrule
Wilcoxon $p$-value & \multicolumn{2}{c}{$9.31 \times 10^{-10}$} \\
\bottomrule
\end{tabular*}
\end{table}

\smallskip
\noindent\textbf{Results.}
We evaluated 30 functions across 4 test-case widths \(\Delta \in \{0, 2, 5, 10\}\), with each measurement repeated 5 times to ensure statistical validity.
Figure~\ref{fig:rq1-responsiveness} illustrates the latency comparison: ByteOp count (x-axis), test-case width $\Delta$ (y-axis), and latency in seconds (z-axis).
Remix's latency scales linearly with both dimensions, reaching an estimated 256--1,287 seconds at $\Delta = 10$, while \textsc{SolQDebug} maintains sub-second latency across all conditions (0.02--3.01s at $\Delta = 10$).

For the statistical comparison in Table~\ref{tab:statistical-comparison}, we focus on $\Delta = 0$ as this condition is most favorable to Remix, requiring only a single transaction execution and thus representing the most conservative comparison.
Under this condition, Remix's debugging workflow latency ranged from 25.6 to 128.7 seconds (mean: 54.62s, median: 51.68s), while \textsc{SolQDebug} completed analysis in 0.02--1.88 seconds (mean: 0.24s, median: 0.09s).
The Wilcoxon signed-rank test~\citep{wilcoxon1945} yielded $p < 0.001$, indicating that such results would be highly improbable if the two tools had equal latency.

This comparison reflects debugging workflow time, measuring how quickly developers gain insights into function behavior.
Note that the two tools are not performing equivalent computational tasks: Remix requires compilation, deployment, and concrete execution tracing,
while \textsc{SolQDebug} provides immediate statement-level abstract summaries during editing.

\medskip
\noindent\fbox{%
\begin{minipage}{0.96\linewidth}
\textbf{Answer to RQ1:}
\textsc{SolQDebug} achieves sub-second feedback (median 0.09s) compared to Remix's compile-deploy-debug cycle (median 51.68s), with statistical significance ($p < 0.001$).
\end{minipage}%
}

\subsection{RQ2 - Impact of Annotation Patterns on Precision in Complex Arithmetic Operations}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{Fig10.pdf}
  \caption{
F90 (90th percentile of interval inflation) for \texttt{Lock::pending} under \texttt{overlap} and \texttt{diff} annotation patterns.
As input width ($\Delta$) increases, \texttt{overlap} achieves progressively tighter precision (F90: 12.0 $\rightarrow$ 4.8),
while \texttt{diff} maintains near-constant inflation (F90 $\approx$ 13--14).}
  \label{fig:rq2-lock}
\end{figure}

Real-world smart contracts frequently use complex arithmetic operations involving multiplication and division
to compute financial quantities such as rewards, fees, and vesting schedules.
These operations inherently amplify interval widths during AI
due to the combinatorial nature of interval arithmetic.
Understanding how annotation structure influences precision in such contexts is critical for practical adoption
of \textsc{SolQDebug}.

To investigate this, the \texttt{pending} function from \texttt{Lock.sol} in the benchmark dataset was examined.
The function uses complex arithmetic operations involving multiplication and division.
Multiplication is critical: in interval arithmetic,
it computes the Cartesian product of endpoint combinations $\{a_{\min} \times b_{\min}, a_{\min} \times b_{\max}, a_{\max} \times b_{\min}, a_{\max} \times b_{\max}\}$.
Consequently, when operand intervals are disjoint, this combinatorial expansion generates significantly wider output ranges.

To assess this effect, two annotation strategies were evaluated under varying input widths $\Delta \in \{1, 3, 6, 10\}$.
In the \texttt{overlap} style, all input variables share a common base range (e.g., $[100, 100+\Delta]$).
In the \texttt{diff} style, each variable occupies a distinct range (e.g., $[100, 100+\Delta]$, $[300, 300+\Delta]$,
$[500, 500+\Delta]$). F90 was measured, the 90th percentile of the inflation factor
$F = \frac{\text{exit\_width}}{\text{input\_width}}$.

As shown in Figure~\ref{fig:rq2-lock}, the \texttt{overlap} strategy consistently produces tighter bounds: as $\Delta$ increases from 1 to 10,
F90 decreases from 12.0 to 4.8, indicating that wider inputs lead to proportionally smaller relative growth.
In contrast, the \texttt{diff} strategy maintains nearly constant inflation (F90 $\approx$ 13--14) regardless of input width.
This difference arises from interval multiplication semantics: when annotations align operands to overlapping ranges,
the extreme products remain closer to the midpoint, limiting excessive interval expansion.
Conversely, disjoint ranges maximize the distance between endpoint combinations, causing output intervals to span unnecessarily large ranges.

Moreover, similar patterns were observed in other contracts from the benchmark dataset that use multiplication or division in their arithmetic.
These include reward computations (GovStakingStorage\_c), fee calculations (GreenHouse\_c, HubPool\_c), vesting schedules (LockupContract\_c), and proportional payouts (ThorusBond\_c).
Across these contracts, overlapping annotations consistently yield tighter precision than disjoint ranges,
demonstrating that developers can significantly improve analysis precision by choosing overlapping rather than disjoint annotations.

\medskip
\noindent\fbox{%
\begin{minipage}{0.96\linewidth}
\textbf{Answer to RQ2:}
For real-world contracts using multiplication or division, overlapping annotations yield significantly lower interval inflation than disjoint annotations, due to interval multiplication's combinatorial nature. Developers should prefer overlapping annotation patterns to improve analysis precision in such contexts.
\end{minipage}%
}

\subsection{RQ3 - Loops}

To evaluate the effectiveness of annotation-guided adaptive widening for loop analysis,
the five loop-containing functions from the benchmark dataset (Table~\ref{tab:benchmark-dataset}) were analyzed:
\texttt{updateUserInfo} (AOC\_BEP), \texttt{\_addActionBuilderAt} (Balancer), \texttt{revokeStableMaster} (Core), \texttt{getTotalDeposit} (TimeLockPool), and \texttt{\_removeFromTokens} (AvatarArtMarketPlace).
These functions exhibit four distinct patterns that demonstrate varying levels of precision under this approach.

\smallskip
\noindent\textbf{Pattern 1: Constant-Bounded Loops.}
When loop conditions reference only constants,
\texttt{EstimateIterations} computes precise thresholds without annotations.
For example, \texttt{updateUserInfo} (AOC\_BEP) uses \texttt{for (uint256 i = 1; i <= 4; i++)}
with $\tau = 4$ computed from the constant bound.
The analysis produces precise interval \texttt{i} $\in [1,5]$ for the loop variable,
where the upper bound reflects the post-increment value when the loop condition becomes false.
Furthermore, \texttt{userInfo[account].level}, assigned within conditional branches followed by \texttt{break},
does not appear in the loop output since \texttt{break} bypasses the fixpoint node.
However, when combined with debugging annotations,
its value at the loop exit (a join of all exit paths) remains available for subsequent analysis.

\smallskip
\noindent\textbf{Pattern 2: Annotation-Enabled Convergence.}
When loop bounds depend on dynamic values but the loop body performs only simple updates,
annotations enable precise convergence.
\texttt{\_addActionBuilderAt} (Balancer) uses \texttt{for (uint8 i = 0; i < additionalCount; i++)}
where \texttt{additionalCount} is computed from function inputs.
With appropriate annotations for \texttt{actionBuilders} and \texttt{index}, the analyzer computes \texttt{additionalCount = 1}, allowing it to set $\tau = 1$ and achieve precise convergence with \texttt{i = [0,1]}.
\texttt{revokeStableMaster} (Core) exhibits similar behavior.
It iterates \texttt{for (uint256 i = 0; i < stablecoinListLength - 1; i++)} with simple index-based operations.
The annotation \texttt{// @StateVar \_stablecoinList = arrayAddress[2,3,4];} yields \texttt{stablecoinListLength = 3}, so the loop bound becomes \texttt{3 - 1 = 2}, setting $\tau = 2$ and achieving precise convergence with \texttt{i = [0,2]}.

\smallskip
\noindent\textbf{Pattern 3: Uninitialized Local Variables (Developer-Fixable).}
When local variables lack explicit initialization, precision loss can occur.
\texttt{getTotalDeposit} (TimeLockPool) declares \texttt{uint256 total;} without initialization
and then accumulates values in a loop.
For example, when appropriate annotations are provided for the \texttt{depositsOf} array elements, the analyzer infers a loop bound of 3 (setting $\tau = 3$) and correctly computes \texttt{i = [0,3]} after the loop.
However, \textsc{SolQDebug} conservatively models uninitialized variables as $\top$ (unknown), causing \texttt{total} to remain $\top = [0, 2^{256}-1]$ regardless of the precise loop bound.

This pattern represents a developer-fixable limitation.
Explicitly initializing \texttt{total = 0} would enable precise tracking (yielding \texttt{total = [700,1000]} for the annotated example).
Annotations cannot compensate for missing initialization because the interval domain soundly treats uninitialized reads as arbitrary values.

\smallskip
\noindent\textbf{Pattern 4: Data-Dependent Accumulation.}
Even when loop bounds are precisely known,
variables that accumulate based on data-dependent conditions may diverge under widening.
\texttt{\_removeFromTokens} (AvatarArtMarketplace) illustrates this limitation.
The loop iterates \texttt{for (uint tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++)}
where \texttt{tokenCount} is known from annotations.
With appropriate annotations for \texttt{\_tokens} and \texttt{tokenId}, the analyzer infers \texttt{tokenCount = 3} (setting $\tau = 3$) and correctly computes \texttt{tokenIndex = [0,3]} after the loop.
However, \texttt{resultIndex} inside the loop increments conditionally (\texttt{if (tokenItemId != tokenId) resultIndex++}) based on array element comparisons, depending on data values rather than the loop index itself.

Once the widening threshold is exceeded, \textsc{SolQDebug} widens \texttt{resultIndex} to $[0, \infty]$.
The interval domain cannot track correlations between array contents and conditional accumulation.
This pattern represents an inherent limitation of the interval domain.
Annotations of iteration bounds cannot prevent widening when variable updates depend on unpredictable data rather than iteration count.

\medskip
\noindent\fbox{%
\begin{minipage}{0.96\linewidth}
\textbf{Answer to RQ3:}
\textsc{SolQDebug} improves loop analysis precision for constant-bounded and annotation-enabled dynamic loops.
Remaining precision loss arises from developer-fixable initialization issues and inherent interval domain limitations in tracking data-dependent accumulation.
\end{minipage}%
}

\subsection{Threats to Validity}

\noindent\textbf{Internal Validity.}
The Remix benchmark was implemented using Selenium-based automation,
which may introduce communication latency between the Python script and the Remix web interface.
Additionally, Remix latencies for $\Delta > 0$ were estimated via linear extrapolation
rather than direct measurement, due to prohibitive execution time.
Actual latencies may vary depending on contract complexity.

\smallskip
\noindent\textbf{External Validity.}
The 30 benchmark functions used in our evaluation may not fully represent
the diversity of real-world smart contracts.
Additionally, due to the current scope limitation,
a user study with developers has not yet been conducted.

\smallskip
\noindent\textbf{Construct Validity.}
We compared \textsc{SolQDebug} only against Remix IDE,
without direct comparison to other debugging tools such as Hardhat Debugger or Foundry Forge Debug.
However, Remix is the most widely used Solidity IDE,
and these alternative tools share the same concrete execution model,
exhibiting similar characteristics in terms of deployment requirements and step-through debugging.

\section{Discussion}

\subsection{Why use Abstract Interpretation with Interval Domain for Debugging}

In this work, debugging refers to a developer-led, interactive exploration activity that occurs during code editing.
Developers specify debug annotations and immediately observe program behaviors at the source level.
This edit-time feedback loop imposes strict requirements on the analysis technique.
Unlike conventional step-through debuggers that trace concrete execution, \textsc{SolQDebug} provides abstract value summaries that characterize possible behaviors across symbolic interval inputs.

\smallskip
\noindent\textbf{Why Abstract Interpretation?}
Compared to other static analysis, dynamic analysis, and machine learning techniques,
AI provides two properties essential for interactive debugging:
\begin{itemize}
  \item \textbf{Termination.} AI enforces convergence through widening at loops and joins at control-flow merges, guaranteeing bounded analysis time regardless of program complexity.

  \item \textbf{Explainability.} AI produces explicit abstract values that developers can inspect and interpret at the statement level.
\end{itemize}

\smallskip
\noindent\textbf{Why Interval Domain?}
Among abstract domains, intervals were chosen for responsiveness. Intervals require only
basic arithmetic on bounds, enabling millisecond-scale updates. In contrast, relational
domains (e.g., zones, polyhedra) track variable correlations through expensive constraint
solving that would break the interactive feedback loop.

\smallskip
\noindent\textbf{Precision-Responsiveness Tradeoff.}
AI with interval domain prioritizes responsiveness over precision, a tradeoff justified
by the interactive debugging context. Edit-time debugging fundamentally requires sub-second
feedback to maintain developer flow. Developers iterate rapidly through code edits,
and analysis delays that exceed even a few seconds would break this interactive loop,
forcing developers back to the traditional compile-deploy-debug cycle.
\textsc{SolQDebug} achieved millisecond-scale feedback latency (RQ1), keeping developers in flow.
Although AI's precision is inherently conservative, this limitation was mitigated
by providing developers with annotation-based techniques to control precision where needed.
The evaluation shows that such techniques can reduce imprecision in practice for common
smart contract patterns (cf.\ RQ2, RQ3).
\vspace{0.25em}

\subsection{Practical Guidelines for Annotation and Loop Design}

\begin{table}[!t]
\centering
\caption{Practical guidelines for maximizing analysis precision, synthesized from RQ2 (arithmetic operations) and RQ3 (loop constructs). Guidelines include annotation strategies and code design patterns.}
\label{tab:guidelines}
\rotatebox{90}{%
\begin{minipage}{0.95\textheight}
\centering
\small
\begin{tabular}{@{}p{2.4cm}p{2.2cm}p{5.5cm}p{6.5cm}@{}}
\toprule
\textbf{Scenario} & \textbf{Detail} & \textbf{Guideline} & \textbf{Rationale} \\
\midrule
\multicolumn{4}{@{}l}{\textit{Arithmetic Operations (RQ2)}} \\[0.4em]

1. Basic principle
& All operators & Annotate \textbf{one operand as interval} (e.g., \texttt{[100,110]}), others as \textbf{singleton} (e.g., \texttt{[100,100]}). & Minimizes interval expansion from combinatorial endpoint calculations. \\[0.5em]
\hdashline\noalign{\vskip 1em}
\multirow[t]{5}{*}{\parbox{2.4cm}{2. Multiple\\intervals needed}}
& \texttt{*}, \texttt{/} & Use \textbf{overlapping} ranges (e.g., \texttt{[100,110]} and \texttt{[100,115]}). & Disjoint ranges maximize spread of endpoint products. \\[0.5em]
& \texttt{+} & Position (overlapping vs.\ disjoint) does not matter. & Result width equals sum of input widths. \\[0.5em]
& \texttt{-} (\texttt{int}) & Position (overlapping vs.\ disjoint) does not matter. & Result width equals sum of input widths. \\[0.5em]
& \texttt{-} (\texttt{uint}) & Use \textbf{disjoint} ranges where minuend $>$ subtrahend (e.g., \texttt{[100,110] - [50,70]}). & Overlapping ranges risk underflow, degrading precision. \\[0.5em]
& \texttt{\%} & Position does not matter. & Result depends on divisor magnitude only. \\[0.5em]

\midrule
\multicolumn{4}{@{}l}{\textit{Loop Constructs (RQ3)}} \\[0.4em]

\multirow[t]{2}{*}{\parbox{2.4cm}{1. Before loop}}
& Initialization & \textbf{Initialize local variables explicitly} (e.g., \texttt{uint x = 0;}). & Uninitialized locals start as $\top$; annotations cannot recover precision. \\[0.5em]
& Bounds annotation & Annotate state variables or parameters determining loop bounds (e.g., array lengths). & Enables precise iteration estimation and widening threshold. \\[0.5em]
\hdashline\noalign{\vskip 1em}
\multirow[t]{3}{*}{\parbox{2.4cm}{2. Inside loop}}
& Simple assignment & Assignments without arithmetic (e.g., \texttt{x = arr[i]}) can converge. & No interval expansion occurs from arithmetic operations. \\[0.5em]
& Index-related arithmetic & Arithmetic where operands relate to loop index (e.g., \texttt{i}, \texttt{arr[i]}) can converge with proper annotation. & The analyzer tracks index-correlated computations. \\[0.5em]
& Index-unrelated arithmetic & Arithmetic on variables unrelated to loop index (e.g., \texttt{if (...) count++}) causes widening. & Interval domain cannot track data-dependent correlations. \\[0.5em]
\hdashline\noalign{\vskip 1em}
3. After loop
& Propagation & Avoid using widened variables in subsequent statements when precise analysis is needed. & Widened intervals propagate imprecision to all dependent computations. \\
\bottomrule
\end{tabular}
\end{minipage}%
}
\end{table}

The experimental findings from RQ2 and RQ3 yield actionable strategies for developers to maximize analysis precision. Table~\ref{tab:guidelines} synthesizes these findings into a unified framework that includes annotation strategies for both arithmetic and loops, as well as code design patterns specifically for loop constructs.

    \subsection{Current Limitations}

    The current implementation addresses single-contract, single-transaction scenarios within a subset of Solidity language features.
    We identify three categories of limitations and outline concrete next steps for real-world challenges.

    \smallskip
    \noindent\textbf{Language Coverage.}
    The current implementation does not support inline assembly blocks.
    Inline assembly allows developers to write raw EVM opcodes within Solidity, bypassing the type system and enabling low-level optimizations.
    Since assembly instructions operate directly on stack and memory without Solidity's semantic abstractions,
    the current CFG construction and abstract interpretation cannot reason about their effects.
    As a minimal viable step, assembly blocks could be treated conservatively by assigning $\top$ to all variables potentially modified within the block.
    A more refined approach would pattern-match common assembly idioms (e.g., \texttt{mload}/\texttt{mstore} for memory operations, \texttt{sload}/\texttt{sstore} for storage)
    and translate them into equivalent abstract operations.

    \smallskip
    \noindent\textbf{Contract Interaction.}
    Inter-contract calls, inheritance hierarchies, and multi-transaction workflows are currently out of scope.
    For multi-contract support, a summary-based approach would analyze callee contracts separately and represent their effects as function summaries (input-output interval relations) at call sites.
    This avoids full inlining while preserving soundness. Multi-transaction analysis would additionally require serializing abstract states between transaction boundaries.

    \smallskip
    \noindent\textbf{User Experience Validation.}
    A formal developer study has not yet been conducted.
    Prior research indicates that meaningful usability evaluation requires assessing ease of use within realistic development workflows~\citep{defisecurity}.
    Since \textsc{SolQDebug} currently addresses only single-contract, single-transaction scenarios without full IDE integration,
    a study at this stage would not accurately reflect usability in complete development settings.
    However, the same study found that practitioners prefer lightweight, development-integrated tools over standalone analyzers.
    \textsc{SolQDebug}'s design aligns with this preference by providing immediate feedback during editing.
    We plan to conduct formal usability studies once multi-contract support and comprehensive IDE integration are implemented.

\section{Related Works}

    \subsection{Solidity IDEs and Debuggers}
        Modern Solidity development environments either embed a debugger or integrate external
        debugging plug-ins. Remix IDE~\citep{remix} is the most widely used web IDE. It supports syntax
        highlighting, one-click compilation, and a bytecode-level debugger that lets users step
        through EVM instructions and inspect stack, memory, and storage. Hardhat~\citep{hardhat}
        is a Node.js-based framework that couples the Solidity compiler with an Ethereum runtime. It integrates with Visual Studio Code extensions to provide step-by-step debugging of transaction execution. Foundry Forge~\citep{forge} is a command-line toolchain oriented toward fast,
        reproducible unit testing. The command \texttt{forge test} spins up an ephemeral fork,
        deploys contracts, executes annotated test functions, and enables replay through Forge Debug.
        Solidity Debugger Pro~\citep{soldepro} is a Visual Studio Code extension that performs runtime debugging over
        concrete transactions and integrates with Hardhat.

        In summary, these debuggers operate on compiled artifacts or post-deployment traces.
        By contrast, \textsc{SolQDebug} targets pre-deployment authoring, accepts partial fragments
        and symbolic annotations, and reports line-level effects via AI during
        editing.

    \subsection{Solidity Vulnerability Detection and Verification}
        Security analysis of smart contracts can be categorized into four main families of
        techniques.
        First, static analysis tools reason over source or bytecode without running the contract.
        Representative systems include rule-based analyzers such as Securify and Slither
        \citep{securify,slither}, symbolic-execution tools like Mythril \citep{mythril},
        knowledge-graph approaches such as Solidet \citep{solidet}, and CFG refinement
        techniques as in Ethersolve \citep{ethersolve}.
        Second, dynamic testing and fuzzing exercise deployed or locally simulated contracts to uncover
        faults and security issues.
        ContractFuzzer mutates Application Binary Interface (ABI)-level inputs \citep{confuzz}, Echidna brings property-based
        fuzzing into developer workflows \citep{echidna}, sFuzz adapts scheduling for higher
        coverage \citep{sfuzz}, TransRacer finds transaction-ordering races \citep{transracer}, and
        Ityfuzz leverages snapshotting to decouple executions from chain nondeterminism
        \citep{ityfuzz}.
        Third, formal verification aims to prove safety properties or refute counterexamples at compile
        time. Examples include ZEUS, VeriSmart, and SmartPulse \citep{zeus,verismart,pulse}.
        Finally, learning-based approaches train models to predict vulnerabilities or triage candidates, e.
        g., via data-flow--aware pretraining, IoT-oriented classifiers, or prompt-tuning for detector
        adaptation \citep{peculiar,tmlvd,pscvfinder}.

        These approaches have substantially advanced vulnerability detection and property checking
        for smart contracts. However, they target complete programs and focus on vulnerability detection rather than providing edit-time feedback. In contrast, \textsc{SolQDebug}
        provides interactive analysis as developers write code, enabling immediate understanding of program behavior without requiring complete contracts.
    
    \subsection{Solidity-Specific Abstract Interpretation Frameworks}
        AI is a well-established framework for static analysis and has been
        adapted to many programming languages. Two recent studies apply it to Solidity~\citep{flow,
        DBM}. The first uses the Pos domain to construct a theoretical model for taint
        (information-flow) analysis~\citep{flow}, while the second uses the Difference-Bound
        Matrix (DBM) domain to generate state invariants and detect re-entrancy vulnerabilities,
        including the DAO attack~\citep{DBM, dao}. However, both approaches operate on fully written
        contracts and provide no support for line-by-line interpretation or developer interaction
        within an IDE.

        \textsc{SolQDebug} builds upon these AI frameworks but targets interactive debugging
        rather than invariant generation or information flow analysis. Unlike these approaches that analyze complete contracts, \textsc{SolQDebug} incrementally updates
        the control-flow graph and abstract state during editing, allowing developers to use debug annotations
        to guide interval analysis and receive edit-time feedback without requiring complete contracts.
    
    \subsection{Interactive Abstract Interpretation for Traditional Languages}
        Beyond Solidity, the broader programming languages community has increasingly focused
        on making abstract interpretation interactive. Recent work integrates static analysis
        directly into IDEs for C, Java, and other traditional languages, delivering live feedback
        during editing \citep{daig, ds, iac, iaj, fap}. While these systems share \textsc{SolQDebug}'s
        goal of edit-time responsiveness, they differ in language semantics, domain requirements,
        and input mechanisms.
        \citet{daig} proposed demanded abstract interpretation, which incrementally rebuilds only
        the analysis nodes touched by an edit.
        A follow-up \citet{ds} generalized this to procedure summaries, enabling inter-procedural
        reuse.
        \citet{iac} extended Goblint with incremental support for multithreaded C, selectively
        recomputing only genuinely affected facts and maintaining IDE-level responsiveness.
        \citet{iaj} introduced IntraJ, a Language Server Protocol (LSP)-integrated analyzer for Java 11 that computes only the
        Abstract Syntax Tree (AST) and data-flow facts needed for the current view, keeping feedback under 100 ms.
        \citet{fap} achieved fast yet precise interval analysis on call graphs via one top-down and
        multiple bottom-up passes, and later introduced an incremental variant that revisits only
        the impacted functions.

        While these frameworks demonstrate the feasibility of interactive abstract interpretation
        in traditional languages, \textsc{SolQDebug} represents the first application of this paradigm
        to Solidity. Beyond language adaptation, it introduces an annotation-guided approach where developers
        specify debug annotations directly in source code to explore multiple execution scenarios in a single analysis pass. This enables Solidity developers to benefit from interactive static analysis without deploying contracts to a blockchain.

\section{Conclusion}
    This paper presented SolQDebug, the first edit-time debugging assistant for Solidity
    designed for interactive analysis within a single contract/transaction context.
    Through interactive parsing, line-to-node indexing for incremental CFG construction, and annotation-guided abstract interpretation,
    SolQDebug provides millisecond-scale feedback on source code.

    Evaluation on 30 real-world DAppSCAN functions demonstrated millisecond-scale feedback latency.
    Our analysis also revealed how annotation patterns affect interval expansion in arithmetic operations and loop constructs, which we synthesized into practical guidelines for developers.
    These results demonstrated that SolQDebug effectively reduces debugging workflow latency, enabling interactive feedback during Solidity development.

    Future work includes extending language coverage to inline assembly, supporting inter-contract calls through summary-based analysis, and multi-transaction workflows.
    Building on this debugging infrastructure, we plan to develop bug detection capabilities targeting numerical defects~\citep{numscout}, with comprehensive IDE integration.

\section*{Acknowledgements}
This work was supported by the Institute of Information \& communications Technology Planning \& Evaluation (IITP) grant funded by the Korean government (MSIT) (RS-2021-II210177, High Assurance of Smart Contract for Secure Software Development Life Cycle).
This work was supported in part by the MSIT(Ministry of Science and ICT), Korea, under the Global Research Support Program in the Digital Field Program(IITP-2024-RS-2022-II221198) supervised by the IITP(Institute of Information & Communications Technology Planning & Evaluation).

\section*{Author Contributions}
Inseong Jeon participated in conceptualization, methodology design, system implementation, data collection, experiments, and manuscript writing. Sundeuk Kim and Hyunwoo Kim assisted in experiments, data collection and analysis, and contributed to manuscript writing. Hoh Peter In provided resources, assisted in editing the manuscript, and supervised the entire project. All authors reviewed and approved the final version of the manuscript.

\section*{Data Availability}
The curated benchmark dataset of 30 Solidity contracts derived from DAppSCAN~\citep{dappscan}, along with the evaluation scripts and experimental results, are available at \url{https://github.com/iwwyou/SolDebug/tree/main}.

\section*{Declarations}

\noindent\textbf{Competing interests} The authors declare no competing interests.

\noindent\textbf{Ethical approval} Not applicable since there are no human and/or animal studies included in this paper.

\begin{thebibliography}{99}

\bibitem[ANTLR(2025)]{antlr}
ANTLR: \url{https://www.antlr.org/} (2025). Accessed November 2025

\bibitem[ChatGPT(2025)]{gpt}
ChatGPT: \url{https://chatgpt.com/} (2025). Accessed November 2025

\bibitem[CoinMarketCap(2025)]{coinmarketcap}
CoinMarketCap: \url{https://coinmarketcap.com/} (2025). Accessed November 2025

\bibitem[Chaliasos et~al.(2024)]{defisecurity}
Chaliasos, S., et al.: Smart contract and defi security tools: Do they meet the needs of practitioners?. In: Proceedings of the 46th IEEE/ACM International Conference on Software Engineering (ICSE), pp. 1--13 (2024). https://doi.org/10.1145/3597503.3623302

\bibitem[Chen et~al.(2025a)]{smart contract evolution}
Chen, X., et al.: Characterizing smart contract evolution. ACM Transactions on Software Engineering and Methodology (2025). https://doi.org/10.1145/3719004

\bibitem[Chen et~al.(2025b)]{numscout}
Chen, J., et al.: NumScout: unveiling numerical defects in smart contracts using LLM-pruning symbolic execution. IEEE Transactions on Software Engineering (2025). https://doi.org/10.1109/TSE.2025.3555622

\bibitem[Chimdyalwar(2024)]{fap}
Chimdyalwar, B.: Fast and precise interval analysis on industry code. In: 2024 IEEE 35th
International Symposium on Software Reliability Engineering Workshops (ISSREW) (2024). https://doi.org/10.1109/ISSREW63542.2024.00049


\bibitem[ConsenSys Diligence(2025)]{psp}
ConsenSys Diligence: Python Solidity Parser. \url{https://github.
com/ConsenSysDiligence/python-solidity-parser} (2025). Accessed November 2025

\bibitem[Cousot and Cousot(1977)]{cousot}
Cousot, P., Cousot, R.: Abstract interpretation: a unified lattice model for static analysis of
programs by construction or approximation of fixpoints. In: Proceedings of the 4th ACM
SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL) (1977). https://doi.org/10.1145/512950.512973

\bibitem[Erhard et~al.(2024)]{iac}
Erhard, J., et al.: Interactive abstract interpretation: reanalyzing multithreaded C programs for
cheap. International Journal on Software Tools for Technology Transfer (2024). https://doi.org/10.1007/s10009-024-00768-9

\bibitem[Foundry Forge(2025)]{forge}
Foundry Forge: \url{https://book.getfoundry.sh/reference/forge/forge/} (2025). Accessed November
2025

\bibitem[Grieco et~al.(2020)]{echidna}
Grieco, G., et al.: Echidna: effective, usable, and fast fuzzing for smart contracts. In:
Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA),
pp. 557--560 (2020). https://doi.org/10.1145/3395363.3404366

\bibitem[Halder et~al.(2023)]{flow}
Halder, R., et al.: Analyzing information flow in Solidity smart contracts. In: Distributed
Computing to Blockchain, pp. 105--123. Academic Press (2023)

\bibitem[Halder(2024)]{DBM}
Halder, R.: State-based invariant property generation of Solidity smart contracts using abstract
interpretation. In: 2024 IEEE International Conference on Blockchain (2024). https://doi.org/10.1109/Blockchain62396.2024.00038

\bibitem[Hardhat(2025)]{hardhat}
Hardhat: \url{https://hardhat.org/} (2025). Accessed November 2025

\bibitem[Hu et~al.(2023)]{solidet}
Hu, T., et al.: Detect defects of Solidity smart contract based on the knowledge graph. IEEE
Transactions on Reliability 73(1), 186--202 (2023). https://doi.org/10.1109/TR.2023.3233999

\bibitem[JetBrains(2025)]{pycharm}
JetBrains: PyCharm. \url{https://www.jetbrains.com/pycharm/} (2025). Accessed November 2025

\bibitem[Jiang et~al.(2018)]{confuzz}
Jiang, B., Liu, Y., Chan, W.K.: ContractFuzzer: fuzzing smart contracts for vulnerability detection.
In: Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering (ASE)
, pp. 259--269 (2018). https://doi.org/10.1145/3238147.3238177

\bibitem[Kalra et~al.(2018)]{zeus}
Kalra, S., Goel, S., Dhawan, M., Sharma, S.: ZEUS: analyzing safety of smart contracts. In:
Proceedings of the 2018 Network and Distributed System Security Symposium (NDSS) (2018). https://doi.org/10.14722/ndss.2018.23082

\bibitem[Llama(2025)]{llama}
Llama: \url{https://www.llama.com/} (2025). Accessed November 2025

\bibitem[Ma et~al.(2023)]{transracer}
Ma, C., Song, W., Huang, J.: TransRacer: function dependence-guided transaction race detection for
smart contracts. In: Proceedings of the 31st ACM Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering (ESEC/FSE), pp. 947--959 (2023). https://doi.org/10.1145/3611643.3616281

\bibitem[Mehar et~al.(2019)]{dao}
Mehar, M.I., et al.: Understanding a revolutionary and flawed grand experiment in blockchain: the
DAO attack. Journal of Cases on Information Technology (2019). https://doi.org/10.4018/JCIT.2019010102

\bibitem[Microsoft(2025)]{visual}
Microsoft Visual Studio: \url{https://visualstudio.microsoft.com/ko/} (2025). Accessed November
2025

\bibitem[Nguyen et~al.(2020)]{sfuzz}
Nguyen, T.D., et al.: sFuzz: an efficient adaptive fuzzer for Solidity smart contracts. In:
Proceedings of the 42nd ACM/IEEE International Conference on Software Engineering (ICSE), pp.
778--788 (2020). https://doi.org/10.1145/3377811.3380334

\bibitem[Pasqua et~al.(2023)]{ethersolve}
Pasqua, M., et al.: Enhancing Ethereum smart-contracts static analysis by computing a precise
control-flow graph of Ethereum bytecode. Journal of Systems and Software 200, 111653 (2023). https://doi.org/10.1016/j.jss.2023.111653

\bibitem[Remix IDE(2025)]{remix}
Remix IDE: \url{https://remix.ethereum.org/} (2025). Accessed November 2025

\bibitem[Remix Benchmark(2025)]{remix_bench}
Remix Benchmark: \url{https://github.com/iwwyou/SolDebug/tree/main/Evaluation/RQ1_Latency/remix} (2025). Accessed November 2025

\bibitem[Riouak et~al.(2024)]{iaj}
Riouak, I., et al.: IntraJ: an on-demand framework for intraprocedural Java code analysis.
International Journal on Software Tools for Technology Transfer (2024). https://doi.org/10.1007/s10009-024-00771-0

\bibitem[Rival and Yi(2020)]{yi}
Rival, X., Yi, K.: Introduction to Static Analysis: an Abstract Interpretation Perspective (2020)


\bibitem[Selenium with Python(2025)]{selenium}
Selenium with Python: \url{https://selenium-python.readthedocs.io/} (2025). Accessed November 2025

\bibitem[Shou et~al.(2023)]{ityfuzz}
Shou, C., Tan, S., Sen, K.: Ityfuzz: snapshot-based fuzzer for smart contract. In: Proceedings of
the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA), pp. 322--333
(2023). https://doi.org/10.1145/3597926.3598059

\bibitem[So et~al.(2020)]{verismart}
So, S., et al.: Verismart: a highly precise safety verifier for Ethereum smart contracts. In: 2020
IEEE Symposium on Security and Privacy (SP), pp. 1678--1694 (2020). https://doi.org/10.1109/SP40000.2020.00032

\bibitem[Sun et~al.(2024)]{gptscan}
Sun, Y., et al.: GPTScan: detecting logic vulnerabilities in smart contracts by combining GPT with program analysis. In: Proceedings of the 46th IEEE/ACM International Conference on Software Engineering (ICSE), pp. 1--13 (2024). https://doi.org/10.1145/3597503.3639117

\bibitem[solcx(2025)]{solcx}
Solidity Compiler in Python (solcx): \url{https://solcx.readthedocs.io/en/latest/} (2025). Accessed
November 2025

\bibitem[Solidity(2025)]{solidity}
Solidity documentation: \url{https://docs.soliditylang.org/en/v0.8.30/} (2025). Accessed November
2025

\bibitem[Solidity Debugger Pro(2025)]{soldepro}
Solidity Debugger Pro: \url{https://www.soliditydbg.org/} (2025). Accessed November 2025

\bibitem[Solidity Language Grammar(2025)]{solgram}
Solidity Language Grammar: \url{https://docs.soliditylang.org/en/v0.8.30/grammar.html} (2025). Accessed November 2025

\bibitem[SolQDebug Implementation(2025)]{solqimpl}
SolQDebug Complete Implementation: \url{https://github.com/iwwyou/SolDebug/tree/main} (2025). Accessed November 2025

\bibitem[SolQDebug Language Grammar Rule(2025)]{solqrule}
Solidity Language Grammar Rule of SolQDebug : \url{https://github.
com/iwwyou/SolDebug/blob/main/Parser/Solidity.g4} . Accessed November 2025

\bibitem[Stein et~al.(2021)]{daig}
Stein, B., Chang, B.-Y.E., Sridharan, M.: Demanded abstract interpretation. In: Proceedings of the
42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI)
(2021). https://doi.org/10.1145/3453483.3454044

\bibitem[Stein et~al.(2024)]{ds}
Stein, B., Chang, B.-Y.E., Sridharan, M.: Interactive abstract interpretation with demanded
summarization. ACM Transactions on Programming Languages and Systems (2024). https://doi.org/10.1145/3648484

\bibitem[Stephens et~al.(2021)]{pulse}
Stephens, J., et al.: SmartPulse: automated checking of temporal properties in smart contracts. In:
2021 IEEE Symposium on Security and Privacy (SP), pp. 555--571 (2021). https://doi.org/10.1109/SP40001.2021.00085

\bibitem[Tsankov et~al.(2018)]{securify}
Tsankov, P., et al.: Securify: practical security analysis of smart contracts. In: Proceedings of
the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS), pp. 67--82 (2018). https://doi.org/10.1145/3243734.3243780

\bibitem[Feist et~al.(2019)]{slither}
Feist, J., Grieco, G., Groce, A.: Slither: a static analysis framework for smart contracts. In: 2019 IEEE/ACM 2nd
International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB), pp. 8--15
(2019). https://doi.org/10.1109/WETSEB.2019.00008


\bibitem[Wilcoxon(1992)]{wilcoxon1945}
Wilcoxon, F.: Individual comparisons by ranking methods. In: Breakthroughs in Statistics: Methodology and Distribution, pp. 196--202. Springer, New York (1992). https://doi.org/10.1007/978-1-4612-4380-9\_16

\bibitem[Wu et~al.(2021)]{peculiar}
Wu, H., et al.: Peculiar: smart contract vulnerability detection based on crucial data-flow graph
and pre-training techniques. In: 2021 IEEE 32nd International Symposium on Software Reliability
Engineering (ISSRE), pp. 378--389 (2021). https://doi.org/10.1109/ISSRE52982.2021.00047

\bibitem[Yao et~al.(2022)]{mythril}
Yao, Y., et al.: An improved vulnerability detection system of smart contracts based on symbolic
execution. In: 2022 IEEE International Conference on Big Data (Big Data), pp. 3225--3234 (2022). https://doi.org/10.1109/BigData55660.2022.10020730

\bibitem[Yu et~al.(2023)]{pscvfinder}
Yu, L., et al.: PSCVFinder: a prompt-tuning based framework for smart contract vulnerability
detection. In: 2023 IEEE 34th International Symposium on Software Reliability Engineering (ISSRE),
pp. 556--567 (2023). https://doi.org/10.1109/ISSRE59848.2023.00030

\bibitem[Zhang(2024)]{accountingerrors}
Zhang, B.: Towards finding accounting errors in smart contracts. In: Proceedings of the 46th IEEE/ACM International Conference on Software Engineering (ICSE), pp. 1--13 (2024). https://doi.org/10.1145/3597503.3639222

\bibitem[Zheng et~al.(2024)]{dappscan}
Zheng, Z., et al.: Dappscan: building large-scale datasets for smart contract weaknesses in dApp
projects. IEEE Transactions on Software Engineering (2024). https://doi.org/10.1109/TSE.2024.3383422

\bibitem[Zhou et~al.(2022)]{tmlvd}
Zhou, Q., et al.: Vulnerability analysis of smart contract for blockchain-based IoT applications: a
machine learning approach. IEEE Internet of Things Journal 9(24), 24695--24707 (2022). https://doi.org/10.1109/JIOT.2022.3196269

\bibitem[Zou et~al.(2019)]{interview}
Zou, W., et al.: Smart contract development: challenges and opportunities. IEEE Transactions on
Software Engineering (2019). https://doi.org/10.1109/TSE.2019.2942301

\end{thebibliography}

\FloatBarrier
\newpage
\appendix

\section{Interactive Parser Grammar Specification}
\label{appendix:interactive-grammar}

This appendix provides the complete grammar specification for \textsc{SolQDebug}'s interactive parser.

\subsection{Entry Rules for Solidity Program Fragments}

\subsubsection{Rule 1: \texttt{interactiveSourceUnit}}
\noindent\textbf{Purpose.} Accepts top-level declarations: functions, contracts, interfaces, libraries, state variables, pragmas, and imports.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveSourceUnit
  : (interactiveStateVariableElement | interactiveFunctionElement
    | interfaceDefinition | libraryDefinition | contractDefinition
    | pragmaDirective | importDirective)* EOF ;
\end{verbatim}

\subsubsection{Rule 2: \texttt{interactiveEnumUnit}}
\noindent\textbf{Purpose.} Accepts enum member items added after the enum shell.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveEnumUnit : (interactiveEnumItems)* EOF;
interactiveEnumItems : identifier (',' identifier)*;
\end{verbatim}

\subsubsection{Rule 3: \texttt{interactiveStructUnit}}
\noindent\textbf{Purpose.} Accepts struct member declarations added after the struct shell.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveStructUnit : (structMember)* EOF;
structMember : typeName identifier ';' ;
\end{verbatim}

\subsubsection{Rule 4: \texttt{interactiveBlockUnit}}
\noindent\textbf{Purpose.} Accepts statements and control-flow skeletons inside function bodies.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveBlockUnit
  : (interactiveBlockItem)* EOF;

interactiveBlockItem
  : interactiveStatement | uncheckedBlock;

interactiveStatement
  : interactiveSimpleStatement
  | interactiveIfStatement
  | interactiveForStatement
  | interactiveWhileStatement
  | interactiveDoWhileDoStatement
  | interactiveTryStatement
  | returnStatement
  | emitStatement
  | revertStatement
  | requireStatement
  | assertStatement
  | continueStatement
  | breakStatement
  | assemblyStatement;

interactiveIfStatement
  : 'if' '(' expression ')' '{' '}' ;

interactiveForStatement
  : 'for' '(' (simpleStatement | ';') expression? ';' expression? ')' '{' '}' ;

interactiveWhileStatement
  : 'while' '(' expression ')' '{' '}' ;

interactiveDoWhileDoStatement
  : 'do' '{' '}' ;

interactiveTryStatement
  : 'try' expression ('returns' '(' parameterList ')')? '{' '}' ;
\end{verbatim}

\noindent The \texttt{interactiveStatement} production includes skeleton rules for
control structures with empty bodies (e.g., \texttt{interactiveIfStatement}, \texttt{interactiveForStatement}),
enabling incremental construction of control flow. As developers type statements inside these
empty bodies, \texttt{interactiveBlockUnit} is recursively invoked to parse each new line.

\subsubsection{Rule 5: \texttt{interactiveDoWhileUnit}}
\noindent\textbf{Purpose.} Accepts the \texttt{while} tail of a \texttt{do\{...\}} loop.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveDoWhileUnit : (interactiveDoWhileWhileStatement)* EOF;
interactiveDoWhileWhileStatement : 'while' '(' expression ')' ';' ;
\end{verbatim}

\subsubsection{Rule 6: \texttt{interactiveIfElseUnit}}
\noindent\textbf{Purpose.} Accepts \texttt{else} or \texttt{else if} branches.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveIfElseUnit : (interactiveElseStatement)* EOF;
interactiveElseStatement : 'else' (interactiveIfStatement | '{' '}') ;
\end{verbatim}

\subsubsection{Rule 7: \texttt{interactiveCatchClauseUnit}}
\noindent\textbf{Purpose.} Accepts \texttt{catch} clauses following a \texttt{try}.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveCatchClauseUnit : (interactiveCatchClause)* EOF;
interactiveCatchClause : 'catch' (identifier? '(' parameterList ')')? '{' '}' ;
\end{verbatim}

\subsection{Entry Rule for Debugging Annotations}

\subsubsection{\texttt{debugUnit}}
\noindent\textbf{Purpose.} Parses batch-annotation lines that specify initial abstract values for variables.

\noindent\textbf{Annotation types:}
\begin{itemize}
  \item \texttt{@GlobalVar}: Assigns values to global variables (e.g., \texttt{msg.sender}, \texttt{block.timestamp})
  \item \texttt{@StateVar}: Assigns values to contract state variables
  \item \texttt{@LocalVar}: Assigns values to function parameters and local variables
\end{itemize}

\noindent\textbf{Grammar:}
\begin{verbatim}
debugUnit : (debugGlobalVar | debugStateVar | debugLocalVar)* EOF;
debugGlobalVar : '//' '@GlobalVar' identifier ('.' identifier)? '=' globalValue ';' ;
debugStateVar : '//' '@StateVar' lvalue '=' value ';' ;
debugLocalVar : '//' '@LocalVar' lvalue '=' value ';' ;
\end{verbatim}

\noindent\textbf{Supported L-value patterns:} Simple variables, array/mapping access (\texttt{arr[i]}, \texttt{map[key]}), struct fields (\texttt{s.field}), and nested combinations.

\noindent\textbf{Value specification:} Integer intervals \texttt{[l,u]}, symbolic addresses \texttt{symbolicAddress n}, boolean values, and symbolic placeholders.

\section{Incremental CFG Construction Patterns}
\label{appendix:cfg-patterns}

This appendix provides the complete CFG construction patterns for \textsc{SolQDebug}'s incremental CFG builder.
The patterns show how each statement type is incrementally spliced into the existing control-flow graph.

\subsection{CFG Hierarchy}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\footnotesize},
  cfgblock/.style={rounded rectangle, draw, thick, minimum width=2.8cm, minimum height=0.85cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (entry) {Entry};
  \node[block, below=of entry] (state) {State Variable Node};
  \node[cfgblock, below=of state] (constructor) {ConstructorCFG};
  \node[cfgblock, below left=1.5cm and 2.5cm of constructor] (func1) {FunctionCFG};
  \node[cfgblock, below=1.5cm of constructor] (func2) {FunctionCFG};
  \node[dots, right=0.5cm of func2] (funcdots) {...};
  \node[cfgblock, below right=1.5cm and 2.5cm of constructor] (funcn) {FunctionCFG};
  \node[block, below=1.5cm of func2] (exit) {Exit};

  \draw[->, thick] (entry) -- (state);
  \draw[->, thick] (state) -- (constructor);
  \draw[->, thick] (constructor) -| (func1);
  \draw[->, thick] (constructor) -- (func2);
  \draw[->, thick] (constructor) -| (funcn);
  \draw[->, thick] (func1) |- (exit);
  \draw[->, thick] (func2) -- (exit);
  \draw[->, thick] (funcn) |- (exit);
\end{tikzpicture}
\caption{Structure of ContractCFG. The contract-level CFG sequences state variable initialization, constructor execution, and all function definitions.}
\label{fig:contract-cfg}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 3cm,
  block/.style={rectangle, draw, thick, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\footnotesize},
  cfgblock/.style={rounded rectangle, draw, thick, minimum width=2.8cm, minimum height=0.85cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  % Main sequence
  \node[block] (entry) {Entry};
  \node[block, below=of entry] (basic) {Basic Node};
  \node[dots, below left=1.5cm and 0.5cm of basic] (dots1) {...};
  \node[dots, below=1.5cm of basic] (dots2) {...};
  \node[dots, below right=1.5cm and 0.5cm of basic] (dots3) {...};
  \node[block, below=3cm of basic] (exit) {Exit};

  % ModifierCFG on the right
  \node[cfgblock, right=of basic] (modifier) {ModifierCFG};

  % Solid edges
  \draw[->, thick] (entry) -- (basic);
  \draw[->, thick] (basic) -- (dots1);
  \draw[->, thick] (basic) -- (dots2);
  \draw[->, thick] (basic) -- (dots3);
  \draw[->, thick] (dots1) |- (exit);
  \draw[->, thick] (dots2) -- (exit);
  \draw[->, thick] (dots3) |- (exit);

  % Bidirectional dashed edges to ModifierCFG
  \draw[<->, thick, dashed] (entry.north) -- ++(0,0.5) -| (modifier.north);
  \draw[<->, thick, dashed] (exit.south) -- ++(0,-0.5) -| (modifier.south);
\end{tikzpicture}
\caption{Structure of FunctionCFG. Each function maintains its own control-flow graph. When modifiers are present, control flows from the function entry to the modifier, and returns from the modifier's placeholder (\texttt{\_}) back to the function body, eventually reaching the function exit.}
\label{fig:function-cfg}
\end{figure}

\subsection{Statement-Level Construction Patterns}

The following patterns show how each statement type is incrementally spliced into the existing control-flow graph.
All patterns assume an initial state with a current node connected to successors (\texttt{...}),
as illustrated in the simple statement example.

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm,
  block/.style={rectangle, draw, thick, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[block, below=of current, fill=green!15] (new) {New Statement\\Node};
  \node[dots, below=of new] (succ) {...};

  \draw[->, thick] (current) -- node[right] {splice} (new);
  \draw[->, thick] (new) -- node[right] {reconnect} (succ);

  % Before state (left side)
  \node[block, left=3cm of current] (before_cur) {Current Node};
  \node[dots, below=of before_cur] (before_succ) {...};
  \draw[->, thick] (before_cur) -- (before_succ);

  \node[above=0.3cm of before_cur, font=\footnotesize\bfseries] {Before};
  \node[above=0.3cm of current, font=\footnotesize\bfseries] {After};
\end{tikzpicture}
\caption{Simple statement insertion: single node spliced between current node and successors}
\label{fig:new-simple-statement}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 1.5cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=of current, fill=green!15] (cond) {condition};
  \node[block, below left=of cond, fill=green!15] (true) {True\\Node};
  \node[block, below right=of cond, fill=green!15] (false) {False\\Node};
  \node[block, below=2.5cm of cond, fill=green!15] (join) {If Join\\Node};
  \node[dots, below=of join] (succ) {...};

  \draw[->, thick] (current) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (false);
  \draw[->, thick] (true) |- (join);
  \draw[->, thick] (false) |- (join);
  \draw[->, thick] (join) -- (succ);
\end{tikzpicture}
\caption{If statement insertion. The builder creates a \texttt{condition node}, two nodes for true/false arms, and an \texttt{if join}}
\label{fig:new-if}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=1.8cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.3cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=1cm of current] (if_cond) {if condition};
  \node[block, below left=1.2cm and 2.2cm of if_cond] (if_true) {If True\\Node};
  \node[dots, below=0.6cm of if_true] (if_dots) {...};

  % else-if branch (highlighted)
  \node[cond, below right=1.2cm and 2.2cm of if_cond, fill=green!15] (elif_cond) {else-if\\condition};
  \node[block, below left=1cm and 1.5cm of elif_cond, fill=green!15] (elif_true) {Else-If True\\Node};
  \node[block, below right=1cm and 1.5cm of elif_cond, fill=green!15] (elif_false) {Else-If False\\Node};

  \node[block, below=2.5cm of elif_cond, fill=green!15] (elif_join) {Else-If Join\\Node};
  \node[block, below=5.5cm of if_cond] (if_join) {If Join\\Node};
  \node[dots, below=0.6cm of if_join] (succ) {...};

  \draw[->, thick] (current) -- (if_cond);
  \draw[->, thick] (if_cond) -| node[above left, pos=0.25] {T} (if_true);
  \draw[->, thick] (if_cond) -| node[above right, pos=0.25] {F} (elif_cond);
  \draw[->, thick] (elif_cond) -| node[above left, pos=0.25] {T} (elif_true);
  \draw[->, thick] (elif_cond) -| node[above right, pos=0.25] {F} (elif_false);
  \draw[->, thick] (if_dots) -- ++(0,-1.5) -| (if_join);
  \draw[->, thick] (elif_true) |- (elif_join);
  \draw[->, thick] (elif_false) |- (elif_join);
  \draw[->, thick] (elif_join) |- (if_join);
  \draw[->, thick] (if_join) -- (succ);
\end{tikzpicture}
\caption{Else-if statement insertion. The builder replaces the false arm with a new \texttt{condition node}, two nodes, and an \texttt{else-if join}}
\label{fig:new-else-if}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=1cm of current] (cond) {condition};
  \node[block, below left=1.2cm and 2cm of cond] (true) {True\\Node};
  \node[dots, below=0.6cm of true] (true_dots) {...};
  \node[block, below right=1.2cm and 2cm of cond, fill=green!15] (else) {Else\\Node};
  \node[dots, below=0.6cm of else] (else_dots) {...};
  \node[block, below=3.5cm of cond] (join) {If Join\\Node};
  \node[dots, below=0.6cm of join] (succ) {...};

  \draw[->, thick] (current) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (else);
  \draw[->, thick] (true) -- (true_dots);
  \draw[->, thick] (else) -- (else_dots);
  \draw[->, thick] (true_dots) -- ++(0,-0.5) -| (join);
  \draw[->, thick] (else_dots) -- ++(0,-0.5) -| (join);
  \draw[->, thick] (join) -- (succ);
\end{tikzpicture}
\caption{Else statement insertion. The builder replaces the false branch node with a new else node, connecting to the \texttt{if join}}
\label{fig:new-else}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2.2cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  phi/.style={circle, draw, thick, fill=blue!15, minimum size=1cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[phi, below=1cm of current, fill=green!15] (phi) {$\phi$};
  \node[cond, below=1cm of phi, fill=green!15] (cond) {condition};
  \node[block, below left=1.2cm and 2.2cm of cond, fill=green!15] (body) {Body\\Entry Node};
  \node[block, below right=1.2cm and 2.2cm of cond, fill=green!15] (exit) {Loop\\Exit Node};
  \node[dots, below=0.6cm of exit] (succ) {...};

  \draw[->, thick] (current) -- (phi);
  \draw[->, thick] (phi) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (body);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (exit);
  \draw[->, thick] (body) -- ++(-1.5,0) |- node[above left, pos=0.15] {back edge} (phi);
  \draw[->, thick] (exit) -- (succ);
\end{tikzpicture}
\caption{While loop insertion. The builder creates a \texttt{fixpoint evaluation node} $\phi$, a \texttt{condition node}, a loop body node, and a \texttt{loop exit node}}
\label{fig:new-while}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2.5cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.3cm, align=center, font=\footnotesize},
  phi/.style={circle, draw, thick, fill=blue!15, minimum size=0.8cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[phi] (phi) {$\phi$};
  \node[cond, below=0.8cm of phi] (cond) {condition};
  \node[block, below left=1cm and 2cm of cond] (body) {Body Node};
  \node[dots, below=0.5cm of body] (body_dots) {...};
  \node[block, below=0.5cm of body_dots, fill=green!15] (break) {\texttt{break}};
  \node[block, below right=1cm and 2cm of cond] (exit) {Loop\\Exit Node};

  \draw[->, thick] (phi) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.2] {T} (body);
  \draw[->, thick] (cond) -| node[above right, pos=0.2] {F} (exit);
  \draw[->, thick] (body) -- (body_dots);
  \draw[->, thick] (body_dots) -- (break);
  \draw[->, thick] (break) -| node[above right, pos=0.6] {redirect} (exit);
\end{tikzpicture}
\caption{Break statement insertion. The \texttt{break} node's outgoing edge is redirected to the \texttt{loop exit node}}
\label{fig:new-break}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2.5cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.3cm, align=center, font=\footnotesize},
  phi/.style={circle, draw, thick, fill=blue!15, minimum size=0.8cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[phi] (phi) {$\phi$};
  \node[cond, below=0.8cm of phi] (cond) {condition};
  \node[block, below left=1cm and 2cm of cond] (body) {Body Node};
  \node[dots, below=0.5cm of body] (body_dots) {...};
  \node[block, below=0.5cm of body_dots, fill=green!15] (continue) {\texttt{continue}};
  \node[block, below right=1cm and 2cm of cond] (exit) {Loop\\Exit Node};

  \draw[->, thick] (phi) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.2] {T} (body);
  \draw[->, thick] (cond) -| node[above right, pos=0.2] {F} (exit);
  \draw[->, thick] (body) -- (body_dots);
  \draw[->, thick] (body_dots) -- (continue);
  \draw[->, thick] (continue) -- ++(-1.5,0) |- node[left, pos=0.25] {redirect} (phi);
\end{tikzpicture}
\caption{Continue statement insertion. The \texttt{continue} node's outgoing edge is redirected to the loop's \texttt{fixpoint evaluation node} $\phi$}
\label{fig:new-continue}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  exit/.style={rectangle, draw, thick, rounded corners, fill=red!15, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[block, below=of current, fill=green!15] (return) {\texttt{return}};
  \node[exit, below right=0.5cm and 2cm of return] (exit) {RETURN\\EXIT};
  \node[dots, below left=0.5cm and 0.5cm of return] (detached) {...};

  \draw[->, thick] (current) -- (return);
  \draw[->, thick, bend left=15] (return) to node[above right] {rewire} (exit);
  \draw[->, thick, dashed, gray] (return) -- node[left, gray] {detached} (detached);
\end{tikzpicture}
\caption{Return statement insertion. The containing node's edge is rewired to the function's unique \texttt{return exit node}}
\label{fig:new-return}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  exit/.style={rectangle, draw, thick, rounded corners, fill=red!15, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=of current, fill=green!15] (cond) {condition};
  \node[block, below left=of cond, fill=green!15] (true) {True\\Node};
  \node[exit, below right=of cond] (error) {ERROR\\EXIT};
  \node[dots, below=of true] (succ) {...};

  \draw[->, thick] (current) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (error);
  \draw[->, thick] (true) -- (succ);
\end{tikzpicture}
\caption{Require/assert statement insertion. The builder creates a \texttt{condition node} with true edge to a node and false edge to the \texttt{error exit node}}
\label{fig:new-require}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  exit/.style={rectangle, draw, thick, rounded corners, fill=red!15, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[block, below=of current, fill=green!15] (revert) {\texttt{revert}};
  \node[exit, below right=0.5cm and 2cm of revert] (error) {ERROR\\EXIT};
  \node[dots, below left=0.5cm and 0.5cm of revert] (detached) {...};

  \draw[->, thick] (current) -- (revert);
  \draw[->, thick, bend left=15] (revert) to node[above right] {rewire} (error);
  \draw[->, thick, dashed, gray] (revert) -- node[left, gray] {detached} (detached);
\end{tikzpicture}
\caption{Revert statement insertion. The containing node's edge is rewired to the function's unique \texttt{error exit node}}
\label{fig:new-revert}
\end{figure}

\section{Abstract Domain and Formal Semantics}
\label{app:semantics}

This appendix presents the abstract domain definitions and formal semantics used by \textsc{SolQDebug}'s abstract interpreter. The framework is based on interval analysis for numeric types, set domains for addresses, and lazy materialization for composite data structures.

\subsection{Language Syntax}

This work considers a subset of Solidity focusing on core control structures, expressions, and state manipulation relevant to the analysis.

\noindent\textbf{Expressions:}
\begin{align*}
e \in \mathsf{Expr}\ ::=\ & n \mid x \mid \mathsf{true} \mid \mathsf{false} \mid \mathsf{address\_literal}\\
& \mid e_1 \oplus e_2 \mid e_1\ \odot\ e_2 \mid e_1\ ?\ e_2 : e_3\\
& \mid e.f \mid e_1[e_2] \mid f(\overline{e}) \mid \neg e \mid \mathsf{delete}\ e
\end{align*}
where $\oplus \in \{+,-,*,/,\%,**,\&\&,||,\&,|,\wedge,<<,>>\}$ and $\odot \in \{<,\le,>,\ge,==,\ne\}$.

\noindent\textbf{Statements:}
\begin{align*}
s \in \mathsf{Stmt}\ ::=\ & \mathsf{skip} \mid s_1; s_2 \mid \tau\ x; \mid \tau\ x = e;\\
& \mid lv := e \mid \mathsf{delete}\ lv\\
& \mid \mathsf{if}\ p\ \mathsf{then}\ s_t\ \mathsf{else}\ s_f\\
& \mid \mathsf{while}\ p\ \mathsf{do}\ s\\
& \mid \mathsf{for}\ init; p; incr\ \mathsf{do}\ s\\
& \mid \mathsf{do}\ s\ \mathsf{while}\ p\\
& \mid \mathsf{return}\ e \mid \mathsf{assert}(p) \mid \mathsf{require}(p)\\
& \mid \mathsf{revert}(\cdots) \mid \mathsf{try}\ e\ (\mathsf{returns}\ (x))\ s_t\ \mathsf{catch}\ s_c\\
& \mid f(\overline{e})
\end{align*}
where $\tau$ ranges over types (\texttt{uint}, \texttt{int}, \texttt{bool}, \texttt{address}, structs, arrays, mappings), $lv$ denotes l-values (variables, fields, array/mapping elements), and $p$ denotes boolean expressions.

\subsection{Abstract Domain}

\noindent\textbf{Atomic abstract values:}
\begin{itemize}
\item \textbf{Unsigned integers:} $\widehat{\mathbb{U}}_N = \{[\ell,u] \mid 0 \le \ell \le u \le 2^N{-}1\} \cup \{\bot,\top^{\mathbb{U}}_N\}$
\item \textbf{Signed integers:} $\widehat{\mathbb{Z}}_N = \{[\ell,u] \mid -2^{N-1} \le \ell \le u \le 2^{N-1}{-}1\} \cup \{\bot,\top^{\mathbb{Z}}_N\}$
\item \textbf{Booleans:} $\widehat{\mathbb{B}} = \{\bot,\widehat{\mathsf{false}},\widehat{\mathsf{true}},\top\}$
\item \textbf{Addresses:} $\widehat{\mathbb{A}} = \{\bot\} \cup \wp_{\text{fin}}(\mathsf{AddrID}) \cup \{\top\}$ where $\bot = \emptyset$ (finite set of symbolic address identifiers)
\item \textbf{Bytes:} $\widehat{\mathbb{BY}}_K = \{\bot,\top_K\}$ (symbolic/opaque)
\item \textbf{Enums:} $\widehat{\mathsf{Enum}}(E) = \{[\ell,u]\mid 0\le \ell \le u \le |E|-1\}\cup\{\bot,\top_E\}$
\end{itemize}

\noindent\textbf{Composite values:}
\begin{itemize}
\item \textbf{Structs:} $\widehat{\mathsf{Struct}}(C) = \prod_{f\in\mathsf{fields}(C)} \widehat{\mathsf{Val}}_f$ (pointwise order)
\item \textbf{Arrays:} $\widehat{\mathsf{Arr}}(\tau) = (\hat{\ell},\hat{d},M)$ where $\hat{\ell}\in \widehat{\mathbb{U}}_{256}$ is length, $\hat{d}$ is default element, $M:\mathbb{N}\rightharpoonup \widehat{\tau}$ stores observed indices
\item \textbf{Mappings:} $\widehat{\mathsf{Map}}(\kappa\Rightarrow\tau) = (\hat{d},M)$ with default $\hat{d}$ and finite map $M$ for observed keys
\end{itemize}

\medskip
\noindent
Standard interval domain operations (order, join, meet, widening, narrowing) apply to integer and enum domains.

\subsection{Concrete Semantics}

\begin{table}[t]
  \caption{Concrete semantics (denotational)}
  \label{tab:conc-denot}
  \centering
  \small
  \setlength{\tabcolsep}{6pt}
  \renewcommand{\arraystretch}{1.12}
  \begin{tabularx}{\columnwidth}{@{}l X@{}}
    \toprule
    \textbf{Statement} & \textbf{Meaning} \\
    \midrule
    \textsf{skip} &
    $\llbracket \textsf{skip}\rrbracket(\sigma)=\Norm(\sigma)$\\

    $s_1; s_2$ &
    $\llbracket s_1; s_2\rrbracket(\sigma)=\big(\llbracket s_1\rrbracket(\sigma)\big)\ \triangleright\ (\lambda \sigma'.\,\llbracket s_2\rrbracket(\sigma'))$\\

    $\tau\ x;$ &
    $\llbracket \tau\ x;\rrbracket(\sigma)=\Norm\!\big(\sigma[x\mapsto \mathrm{zero}_\tau]\big)$\\

    $\tau\ x=e;$ &
    $\llbracket \tau\ x=e;\rrbracket(\sigma)=\Norm\!\big(\sigma[x\mapsto \llbracket e\rrbracket_\sigma]\big)$\\

    $\mathit{lv}:=e$ &
    $\llbracket \mathit{lv}:=e\rrbracket(\sigma)=\Norm\!\big(\mathrm{write}(\sigma,\,\mathrm{loc}_\sigma(\mathit{lv}),\,\llbracket e\rrbracket_\sigma)\big)$\\

    \textsf{delete}\ $\mathit{lv}$ &
    $\llbracket \textsf{delete}\ \mathit{lv}\rrbracket(\sigma)=\Norm\!\big(\mathrm{write}(\sigma,\,\mathrm{loc}_\sigma(\mathit{lv}),\,\mathrm{zero}_{\tau(\mathit{lv})})\big)$\\

    \textsf{if}\ $p$ \textsf{then}\ $s_t$ \textsf{else}\ $s_f$ &
    $\llbracket \cdot\rrbracket(\sigma)=
      \begin{cases}
        \llbracket s_t\rrbracket(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \llbracket s_f\rrbracket(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$\\

    \textsf{while}\ $p$ \textsf{do}\ $s$ &
    $F(H)(\sigma)=
      \begin{cases}
        \big(\llbracket s\rrbracket(\sigma)\big)\ \triangleright\ H & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \Norm(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$;
    $\llbracket \textsf{while}\ p\ \textsf{do}\ s\rrbracket=\mathrm{lfp}(F)$\\

    \textsf{for}\ $init$; $p$; $incr$ \textsf{do}\ $s$ &
    $F(H)(\sigma)=
      \begin{cases}
        \big(\llbracket s\rrbracket(\sigma)\big)\ \triangleright\ (\lambda \sigma'.\,\llbracket incr\rrbracket(\sigma')\ \triangleright\ H) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \Norm(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$;
    $\llbracket \textsf{for}\ init; p; incr\ \textsf{do}\ s\rrbracket(\sigma)=\llbracket init\rrbracket(\sigma)\ \triangleright\ (\lambda \sigma'.\,\mathrm{lfp}(F)(\sigma'))$\\

    \textsf{do}\ $s$ \textsf{while}\ $p$ &
    $F(H)(\sigma)=\llbracket s\rrbracket(\sigma)\ \triangleright\ (\lambda \sigma'.\,
      \begin{cases}
        H(\sigma') & \text{if }\llbracket p\rrbracket_{\sigma'}=\mathsf{true},\\
        \Norm(\sigma') & \text{if }\llbracket p\rrbracket_{\sigma'}=\mathsf{false}
      \end{cases})$;
    $\llbracket \textsf{do}\ s\ \textsf{while}\ p\rrbracket=\mathrm{lfp}(F)$\\

    \textsf{return}\ $e$ &
    $\llbracket \textsf{return}\ e\rrbracket(\sigma)=\Ret(\llbracket e\rrbracket_\sigma,\,\sigma)$\\

    \textsf{assert}$(p)$,\ \textsf{require}$(p)$ &
    $\llbracket \cdot\rrbracket(\sigma)=
      \begin{cases}
        \Norm(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \Abort & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$\\

    \textsf{revert}$(\cdots)$ &
    $\llbracket \textsf{revert}(\cdots)\rrbracket(\sigma)=\Abort$\\

    \textsf{try}\ $e$ (\textsf{returns}\ $(x)$)\ $s_t$ \textsf{catch}\ $s_c$ &
    $\llbracket \cdot\rrbracket(\sigma)=
      \begin{cases}
        \llbracket s_t\rrbracket(\sigma[x\mapsto v]) & \text{if call succeeds with }v,\\
        \llbracket s_c\rrbracket(\sigma) & \text{if call reverts}
      \end{cases}$\\

    \textsf{call}$(\overline{e})$ &
    Internal: parameter binding; external: unspecified\\
    \bottomrule
  \end{tabularx}
\end{table}

\noindent\textbf{Result types:} Semantics return $\Norm(\sigma)$ (normal termination), $\Ret(v,\sigma)$ (return statement), or $\Abort$ (revert).

\medskip
\begin{itemize}
\item \textbf{Variables:} $\mathsf{Var}$ = set of variable identifiers
\item \textbf{Values:} $\mathsf{Val}$ includes:
  \begin{itemize}
  \item Unsigned integers: $\mathbb{U}_N = \{0,1,\ldots,2^N{-}1\}$
  \item Signed integers: $\mathbb{Z}_N = \{-2^{N-1},\ldots,2^{N-1}{-}1\}$
  \item Booleans: $\mathbb{B} = \{\mathsf{true},\mathsf{false}\}$
  \item Addresses: $\mathbb{A} = \mathsf{AddrID}$ (symbolic identifiers)
  \item Composite values: structs, arrays, mappings with concrete elements
  \end{itemize}
\item \textbf{Stores:} $\sigma \in \Sigma = \mathsf{Var} \rightharpoonup \mathsf{Val}$
\end{itemize}

\medskip
\noindent
L-value resolution $\mathrm{loc}_\sigma(\mathit{lv})$ and write $\mathrm{write}(\sigma,\ell,v)$ update the store. Expressions are pure: $\llbracket e\rrbracket_\sigma\in\mathsf{Val}$.

\noindent\textbf{Array/mapping materialization:}
$\mathrm{loc}_\sigma(a[i])$ extends $a$ up to $i$ with defaults if needed; $\mathrm{loc}_\sigma(m[k])$ creates $m[k]$ lazily if absent.

\subsection{Collecting Semantics}

For abstraction, we lift concrete semantics to sets of states.

\noindent\textbf{Collecting function semantics:} Given a function $f$ with concrete semantics $\llbracket f \rrbracket : \Sigma \times \mathsf{Val} \to \mathit{Result}$, the collecting semantics over state sets is:
\[
\mathcal{S}[[f]](S) = \{\sigma' \mid \exists \sigma \in S,\, v_{\text{in}} \in \mathsf{Val}.\, \llbracket f \rrbracket(\sigma, v_{\text{in}}) = \Norm(\sigma') \vee \llbracket f \rrbracket(\sigma, v_{\text{in}}) = \Ret(v_{\text{out}}, \sigma')\}
\]

\noindent\textbf{Reachable states:} The set of all reachable states during contract execution forms the collecting semantics, serving as the basis for abstract interpretation.

\subsection{Abstract Semantics (Denotational)}

Our abstract semantics is based on the well-established Galois connection for interval domains between concrete and abstract semantics, ensuring soundness. The abstraction function $\alpha$ and concretization function $\gamma$ connect concrete and abstract domains, guaranteeing that abstract computations safely over-approximate concrete behaviors.

\smallskip
\noindent\textbf{Abstract semantic domains:}
\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt]
\item \textbf{Abstract values:} $\widehat{\mathsf{Val}}$ = union of atomic abstract values ($\widehat{\mathbb{U}}_N$, $\widehat{\mathbb{Z}}_N$, $\widehat{\mathbb{B}}$, $\widehat{\mathbb{A}}$, etc.) and composite abstract values ($\widehat{\mathsf{Struct}}$, $\widehat{\mathsf{Arr}}$, $\widehat{\mathsf{Map}}$) from \S\ref{app:semantics}
\item \textbf{Abstract stores:} $\hat{\sigma} \in \widehat{\Sigma} = \mathsf{Var} \rightharpoonup \widehat{\mathsf{Val}}$
\end{itemize}

\smallskip
\noindent\textbf{Auxiliary functions:}
\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt]
\item $\mathrm{refine}(\hat{\sigma},p,b)$: narrows operands of $p$ by interval meets
\item $\widehat{\mathrm{write}}(\hat{\sigma},\mathit{lv},\hat{v})$: strong update if singleton index/key, weak update otherwise
\item $\mathrm{joinRes}(r_1,r_2)$: componentwise join of abstract results
\end{itemize}

\begin{table}[h]
  \caption{Abstract semantics (denotational)}
  \label{tab:abs-denot}
  \centering
  \small
  \setlength{\tabcolsep}{6pt}
  \renewcommand{\arraystretch}{1.12}
  \begin{tabularx}{\columnwidth}{@{}l X@{}}
    \toprule
    \textbf{Statement} & \textbf{Meaning} \\
    \midrule
    \textsf{skip} &
    $\llbracket \textsf{skip}\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}(\hat{\sigma})$\\

    $s_1; s_2$ &
    $\llbracket s_1; s_2\rrbracket^\sharp(\hat{\sigma})=\big(\llbracket s_1\rrbracket^\sharp(\hat{\sigma})\big)\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\llbracket s_2\rrbracket^\sharp(\hat{\sigma}'))$\\

    $\tau\ x;$ &
    $\llbracket \tau\ x;\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\hat{\sigma}[x\mapsto \hat{\mathrm{init}}(\tau)]\big)$\\

    $\tau\ x=e;$ &
    $\llbracket \tau\ x=e;\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\hat{\sigma}[x\mapsto \alpha_\tau(\llbracket e\rrbracket^\sharp_{\hat{\sigma}})]\big)$\\

    $\mathit{lv}:=e$ &
    $\llbracket \mathit{lv}:=e\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\widehat{\mathrm{write}}(\hat{\sigma},\,\mathit{lv},\,\llbracket e\rrbracket^\sharp_{\hat{\sigma}})\big)$\\

    \textsf{delete}\ $\mathit{lv}$ &
    $\llbracket \textsf{delete}\ \mathit{lv}\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\widehat{\mathrm{write}}(\hat{\sigma},\,\mathit{lv},\,\hat{\mathrm{zero}}_{\tau(\mathit{lv})})\big)$\\

    \textsf{if}\ $p$ \textsf{then}\ $s_t$ \textsf{else}\ $s_f$ &
    $\hat{\sigma}_t=\mathrm{refine}(\hat{\sigma},p,\mathsf{true})$, $\hat{\sigma}_f=\mathrm{refine}(\hat{\sigma},p,\mathsf{false})$;
    $\llbracket \cdot\rrbracket^\sharp(\hat{\sigma})=\mathrm{joinRes}\!\big(\llbracket s_t\rrbracket^\sharp(\hat{\sigma}_t),\ \llbracket s_f\rrbracket^\sharp(\hat{\sigma}_f)\big)$\\

    \textsf{while}\ $p$ \textsf{do}\ $s$ &
    $G^\sharp(H)(\hat{\sigma})=\mathrm{joinRes}\big(
      \llbracket s\rrbracket^\sharp(\mathrm{refine}(\hat{\sigma},p,\mathsf{true}))\ \triangleright^\sharp\ H,\;
      \widehat{\Norm}(\mathrm{refine}(\hat{\sigma},p,\mathsf{false}))
    \big)$;
    $\llbracket \textsf{while}\ p\ \textsf{do}\ s\rrbracket^\sharp = \mathrm{lfp}^{\nabla}(G^\sharp)$\\

    \textsf{for}\ $init$; $p$; $incr$ \textsf{do}\ $s$ &
    $G^\sharp(H)(\hat{\sigma})=\mathrm{joinRes}\big(
      \llbracket s\rrbracket^\sharp(\mathrm{refine}(\hat{\sigma},p,\mathsf{true}))\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\llbracket incr\rrbracket^\sharp(\hat{\sigma}')\ \triangleright^\sharp\ H),\;
      \widehat{\Norm}(\mathrm{refine}(\hat{\sigma},p,\mathsf{false}))
    \big)$;
    $\llbracket \textsf{for}\ init; p; incr\ \textsf{do}\ s\rrbracket^\sharp(\hat{\sigma})=
      \llbracket init\rrbracket^\sharp(\hat{\sigma})\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\mathrm{lfp}^{\nabla}(G^\sharp)(\hat{\sigma}'))$\\

    \textsf{do}\ $s$ \textsf{while}\ $p$ &
    $G^\sharp(H)(\hat{\sigma})=\llbracket s\rrbracket^\sharp(\hat{\sigma})\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\mathrm{joinRes}\big(
      H(\mathrm{refine}(\hat{\sigma}',p,\mathsf{true})),\;
      \widehat{\Norm}(\mathrm{refine}(\hat{\sigma}',p,\mathsf{false}))
    \big))$;
    $\llbracket \textsf{do}\ s\ \textsf{while}\ p\rrbracket^\sharp = \mathrm{lfp}^{\nabla}(G^\sharp)$\\

    \textsf{return}\ $e$ &
    $\llbracket \textsf{return}\ e\rrbracket^\sharp(\hat{\sigma})=\widehat{\Ret}(\llbracket e\rrbracket^\sharp_{\hat{\sigma}},\,\hat{\sigma})$\\

    \textsf{assert}$(p)$,\ \textsf{require}$(p)$ &
    $\widehat{\Norm}(\mathrm{refine}(\hat{\sigma},p,\mathsf{true}))$ if $p$ must-hold; $\widehat{\Abort}$ if $p$ must-fail; $\mathrm{joinRes}$ otherwise\\

    \textsf{revert}$(\cdots)$ &
    $\llbracket \textsf{revert}(\cdots)\rrbracket^\sharp(\hat{\sigma})=\widehat{\Abort}$\\

    \textsf{try}\ $e$ (\textsf{returns}\ $(x)$)\ $s_t$ \textsf{catch}\ $s_c$ &
    $\llbracket \cdot\rrbracket^\sharp(\hat{\sigma})=\mathrm{joinRes}\!\big(
      \llbracket s_t\rrbracket^\sharp(\hat{\sigma}[x\mapsto \top]),\
      \llbracket s_c\rrbracket^\sharp(\hat{\sigma})
    \big)$\\

    \textsf{call}$(\overline{e})$ &
    Internal: parameter binding; external: havoc footprint or $\widehat{\Abort}$\\
    \bottomrule
  \end{tabularx}
\end{table}

\end{document}
