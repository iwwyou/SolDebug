% Pass options to packages before documentclass to avoid option clash
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{colorlinks=true,linkcolor=blue,urlcolor=blue,citecolor=black}{hyperref}

\documentclass[pdflatex,sn-basic]{sn-jnl}% Basic style with author-year citations

% Korean language support
\usepackage[utf8]{inputenc}
%\usepackage{kotex}  % Commented out - package not found

% Math packages first
\usepackage{amsmath}%
\usepackage{amssymb}%
\usepackage{amsfonts}%
\usepackage{amsthm}%
\usepackage{amsopn}%
\usepackage{amstext}%
\usepackage{mathrsfs}%
\usepackage{stmaryrd}% For llbracket, rrbracket

% Graphics and tables
\usepackage{graphicx}%
\DeclareGraphicsExtensions{.png,.pdf,.jpg}% PNG first, then PDF
\usepackage{subcaption}% For subfigure environment
\usepackage{caption}% For caption customization
\captionsetup{justification=raggedright, singlelinecheck=false}% Left-align all captions by default
\captionsetup[figure]{justification=centering, singlelinecheck=false}% Center-align figure captions
\usepackage{tikz}%
\usetikzlibrary{positioning,shapes,arrows.meta}%
\usepackage{multirow}%
\usepackage{booktabs}%
\usepackage{tabularx}
\usepackage{array}

% Algorithm packages
\usepackage{algorithm}%
\usepackage{algorithmicx}%
\usepackage{algpseudocode}%

% Other packages
\usepackage[title]{appendix}%
\usepackage{placeins}% For \FloatBarrier to control figure placement
\usepackage{float}% For [H] option to force exact placement
\usepackage{xcolor}%
\usepackage{textcomp}%
% \usepackage{manyfoot}% Package not available in MiKTeX
\usepackage{listings}%
\usepackage{comment}
\usepackage{enumitem}% For list spacing control
\newcolumntype{L}{>{\raggedright\arraybackslash}X}

% Define Solidity language for listings
\lstdefinelanguage{Solidity}{
  keywords={contract, function, modifier, public, private, external, internal, view, pure, payable, returns, return, if, else, for, while, require, assert, mapping, address, uint256, uint, bool, string, memory, storage, calldata, event, emit, struct, enum, constructor, msg, this, new, delete, break, continue, throw, revert},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={true, false, null, this, new},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\theoremstyle{thmstyleone}%
\newtheorem{theorem}{Theorem}%  meant for continuous numbers
\newtheorem{proposition}[theorem]{Proposition}%
\theoremstyle{thmstyletwo}%
\newtheorem{example}{Example}%
\newtheorem{remark}{Remark}%

\theoremstyle{thmstylethree}%
\newtheorem{definition}{Definition}%

\raggedbottom

% Using author-year style to match submission guidelines
\bibpunct{(}{)}{;}{a}{,}{ } % a = author-year citations

% URL breaking settings (hyperref and url already loaded by sn-jnl.cls)
\Urlmuskip=0mu plus 1mu
\def\UrlBreaks{\do\/\do-\do\_\do\.\do\?\do\&}

\makeatletter
\renewcommand\@biblabel[1]{} % Remove numeric labels like [1]
\makeatother
\setlength{\bibsep}{0.2em}   % Space between bibliography items
\setlength{\bibhang}{2em}

% Custom math commands
\newcommand{\Abort}{\mathsf{Abort}}
\newcommand{\Norm}{\mathsf{Norm}}
\newcommand{\Ret}{\mathsf{Ret}}
\newcommand{\Env}{\mathit{Env}}

\begin{document}

\title[Article Title]{SolQDebug: Debug Solidity Quickly for Interactive Immediacy in Smart Contract
Development}

\author[1]{\fnm{Inseong} \sur{Jeon}}\email{iwwyou@korea.ac.kr}

\author[1]{\fnm{Sundeuk} \sur{Kim}}\email{sd\_kim@korea.ac.kr}

\author[1]{\fnm{Hyunwoo} \sur{Kim}}\email{khw0809@korea.ac.kr}

\author*[1]{\fnm{Hoh Peter} \sur{In}}\email{hoh\_in@korea.ac.kr}

\affil*[1]{\orgdiv{Department of Computer Science}, \orgname{Korea University},
\orgaddress{\street{145, Anam-ro}, \city{Seonbuk-gu}, \postcode{02841}, \state{Seoul},
\country{Republic of Korea}}}


\abstract{As Solidity becomes the dominant language for blockchain smart contracts,
efficient debugging grows increasingly critical. However, current Solidity debugging
remains inefficient: developers must compile, deploy, set up transactions,
and step through execution line-by-line to examine each variable. This process is too slow for
practical use. To address this challenge, this paper presented \textsc{SolQDebug}, the first
interactive source-level debugger for Solidity that delivered millisecond feedback directly
on source code. Developers specify input value ranges through annotations and compare them
against abstract interpretation results, thereby enabling exploration of contract behavior
across multiple execution paths. \textsc{SolQDebug} was evaluated on 30 real-world functions
from DAppSCAN, achieving 350$\times$ faster debugging (0.15s vs. 53s per function) than Remix IDE.
The evaluation provided debugging insights: overlapping annotation patterns improved
precision in most Solidity debugging scenarios, while analysis of diverse loop patterns
demonstrated improved convergence while preserving soundness guarantees. These results
demonstrated that \textsc{SolQDebug} enabled interactive debugging for Solidity development.}


\keywords{Smart Contract Development, Solidity, Debugging, Abstract Interpretation, Incremental Analysis}

\maketitle

\section{Introduction}\label{sec1}

    Blockchain technology has evolved from a simple cryptocurrency platform into a comprehensive ecosystem for decentralized applications.
    At the center of this evolution, Ethereum ranks second in market capitalization at over \$460 billion~\citep{coinmarketcap}.
    This ecosystem is powered by smart contracts written primarily in Solidity~\citep{solidity}, the dominant language for contract development.
    As these contracts grow more complex and handle increasing value, ensuring their correctness becomes critical.
    This is especially critical because once deployed to the blockchain, contracts are immutable and cannot be easily fixed.
    Recently, many developers rely on large language models (LLMs) such as ChatGPT~\citep{gpt} or Llama~\citep{llama} for code generation assistance.
    However, these tools cannot provide formal correctness guarantees.
    Therefore, developers must still rigorously understand program behavior at the statement level during editing.

    Unfortunately, the debugging workflow for Solidity lacks the maturity of traditional programming environments. Even a single inspection requires full compilation, deployment, manual state initialization, and manual bytecode-level tracing. Moreover, once a transaction modifies contract state, reverting to previous conditions requires costly redeployment or manual reconstruction, making iterative debugging impractical. Tools like Remix IDE~\citep{remix}, Hardhat~\citep{hardhat}, and
    Foundry Forge~\citep{forge} suffer from these fundamental limitations. A prior study found that 88.8\% of Solidity developers described debugging as painful. Moreover, 69\% attributed this pain to the absence of interactive source-level tooling~\citep{interview}. To the
    best of our knowledge, no existing research or tooling provides interactive feedback during
    Solidity code editing, a gap that this paper aims to fill.
    
    This paper presented \textsc{SolQDebug}, a source-level interactive Solidity debugger powered by abstract interpretation (AI) with interval domain.
    Unlike traditional debugging workflows that require compilation and deployment, \textsc{SolQDebug} provided live feedback as developers typed, helping them understand program behavior at the statement level.
    To achieve this goal, \textsc{SolQDebug} built on two core ideas.
    First, it provided incremental analysis through interactive parsing and incremental CFG construction via line-to-node indexing.
    As developers type each statement, the system efficiently determines insertion sites and extends the CFG, recomputing abstract states
    only for affected program points.
    Second, it enabled annotation-guided exploration. Developers specified symbolic interval inputs
    directly in source code, and the interpreter used these ranges to analyze multiple execution
    paths in a single pass.

    To validate these design choices, \textsc{SolQDebug} was evaluated on 30 real-world functions from DAppSCAN~\citep{dappscan}.
    The evaluation demonstrated millisecond-scale responsiveness and examined how annotation structure
    affected precision across common smart contract patterns. The results also showed how annotation-guided analysis
    addressed the precision challenges typically encountered in loops.

    This paper makes the following contributions:
    
    \begin{itemize}
      \item This work identified the main barriers to interactive Solidity debugging: (1) temporal inefficiency from compilation, deployment, and state initialization, and (2) iterative inefficiency from EVM constraints that prevent repeated execution with different states.
      \item An interactive parser with seven specialized entry rules and line-to-node indexing was designed that enables incremental CFG construction with efficient statement insertion during live editing.
      \item An annotation-guided abstract interpreter with adaptive widening was introduced that mitigates precision challenges in loop analysis while maintaining termination guarantees.
      \item \textsc{SolQDebug} was evaluated on 30 real-world functions from DAppSCAN, demonstrating a 350$\times$ median speedup over Remix IDE. The evaluation demonstrated that overlapping annotation patterns improve precision in common smart contract patterns and provided guidance on annotation design.
    \end{itemize}

\section{Background}\label{sect2}
    \subsection{Structure of Solidity Smart Contract}

\begin{figure}[t]
\begin{lstlisting}[language=Solidity, numbers=left, basicstyle=\ttfamily\small]
contract Example {
    address public owner;
    uint256 public totalSupply = 1000;
    mapping(address => uint256) private balances;

    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    function burn(uint256 amount) public onlyOwner {
        uint256 bal = balances[msg.sender];
        uint256 delta;
        if (bal >= amount) {
            balances[msg.sender] = bal - amount;
            delta = amount;
        }
        else {
            delta = 0;
        }
        totalSupply -= delta;
    }
}
\end{lstlisting}
\caption{Minimal example used to illustrate grammar elements relevant to our analysis}
\label{fig:grammar-min}
\end{figure}

        Figure~\ref{fig:grammar-min} illustrates the key structural elements of a Solidity smart
        contract. At the top level, Solidity programs may declare contracts, interfaces, and
        libraries. A contract is composed of variables and functions. The following first describes the variable categories.

        Variables are categorized by their scope and lifetime. Global variables such as
        \texttt{msg.sender} (appearing at line 7) and \texttt{block.timestamp} represent read-only
        EVM metadata provided implicitly by the runtime. State variables such as \texttt{owner},
        \texttt{totalSupply}, and \texttt{balances} (lines 2--4) persist across transactions and
        provide the contract's permanent storage. Local variables such as \texttt{bal} and \texttt{delta} (lines 12--13) are
        scoped to a single function call and do not persist beyond execution.

        Functions such as \texttt{burn} (lines 11--22) use control flow constructs including \texttt{if}/\texttt{else}, \texttt{while}/\texttt{for}/\texttt{do-while},
        \texttt{break}/\texttt{continue}, and \texttt{return}. Functions can be augmented with
        modifiers. The \texttt{onlyOwner} modifier (lines 6--9) performs a precondition check before
        the function body executes. The placeholder underscore at line 8 marks where the original
        function body is inserted when the modifier is inlined. These structural elements define
        Solidity contracts.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Fig2.pdf}
  \caption{Traditional Solidity debugging workflow: Compile step}
  \label{fig:step-compile}
\end{figure}

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Fig3.pdf}
  \caption{Traditional Solidity debugging workflow: Deploy contract}
  \label{fig:step-deploy}
\end{figure}

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Fig4.pdf}
  \caption{Traditional Solidity debugging workflow: Send preparatory transactions}
  \label{fig:step-init}
\end{figure}

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{Fig5.pdf}
  \caption{Traditional Solidity debugging workflow: Bytecode-level debugging}
  \label{fig:step-debug}
\end{figure}

    \subsection{Solidity Execution and Debugging Workflow}
        Unlike traditional programs, Solidity contracts require blockchain deployment before
        execution. Deployment is a one-time transaction that stores compiled bytecode on-chain
        and invokes the constructor. Once deployed, the bytecode becomes immutable.

        After deployment, users interact with the contract by invoking public functions through
        blockchain transactions. Once a transaction is mined into a block, the EVM jumps to the
        designated entry point and executes the corresponding function sequentially. Crucially,
        the execution model is strictly state-based. State variables persist across transactions,
        forming a global storage that is shared by all function calls. Each transaction can read
        from and write to this persistent state, and these modifications become permanent once
        the transaction is confirmed. This state-based execution model introduces a critical constraint. Changes to contract
        state cannot be undone automatically and require costly external actions such as
        redeployment or manual state reconstruction.

        These constraints directly impact the debugging process. To debug Solidity code,
        developers must follow a multi-stage workflow illustrated in
        Figures~\ref{fig:step-compile}--\ref{fig:step-debug}. Before invoking the target function, the contract must be
        compiled, deployed to the blockchain, and its state must be manually initialized through setup transactions to satisfy any
        preconditions. The target function is then invoked, and its execution is traced step by step
        at the bytecode level. This workflow interacts with the execution model constraints described
        above, introducing significant challenges in the debugging process.

    \subsection{Two Sources of Inefficiency in Solidity Debugging}
        The workflow described above reveals temporal and iterative inefficiencies. These issues stem from
        two orthogonal obstacles that make debugging Solidity programs significantly slower than
        traditional application development.

        \smallskip
        \noindent\textbf{(1) Environmental disconnect between editor and execution engine causes temporal inefficiency.}
        Unlike conventional IDEs such as PyCharm~\citep{pycharm} or Visual Studio~\citep{visual},
        where the source editor and execution engine run in the same process, Solidity development
        involves external coordination with a blockchain node at every stage. The multi-stage
        workflow described in the previous subsection introduces several seconds to minutes of
        latency per iteration, preventing the immediate feedback that developers expect when writing
        and testing code.

        Given this workflow overhead, developers often rely on \texttt{emit} logs or event outputs to
        observe intermediate values. However, such instrumentation provides only runtime snapshots
        and lacks the structural insight needed to understand symbolic variation or control-flow
        behavior. Moreover, modifying the expression of interest typically requires recompilation and
        redeployment, compounding latency and disrupting iteration. The final stage, tracing raw EVM
        opcodes, is particularly costly because developers are forced to mentally reconstruct
        source-level semantics. This not only adds execution overhead but also imposes significant
        cognitive burden during fault localization and fix validation.

        \smallskip
        \noindent\textbf{(2) Architectural limitations of EVM cause iterative inefficiency.}
        The EVM's state-based execution model makes state modifications irreversible. This constraint
        fundamentally conflicts with iterative debugging, which requires repeatedly re-executing the
        same function under different conditions.

        Additionally, if a function includes conditional guards that depend on the current state such
        as account balances or counters, then any debugging session must first ensure that those
        conditions are satisfied. For example, consider a function that enforces a check on
        \texttt{\_balances[account]}. Developers must manually assign a sufficient balance before
        they can observe the downstream effects on \texttt{\_totalSupply}. Without such setup, the
        function exits early, preventing inspection of the intended execution path.

        In short, these constraints make repeated debugging iterations costly and fragile. According
        to a developer study~\citep{interview}, 88.8\% of Solidity practitioners reported frustration
        with current debugging workflows, with 69\% attributing this to the lack of interactive,
        state-aware tooling. The next subsection outlines our proposed approach to address these two
        root causes.

    \subsection{Proposed Approach Overview}

    \textsc{SolQDebug} addresses the two root causes of Solidity's debugging bottleneck through a
    pair of complementary techniques. The first technique targets temporal inefficiency by eliminating
    blockchain round trips, while the second addresses iterative inefficiency by enabling state manipulation.

    \smallskip
    \noindent\textbf{(1) Removing the multi-stage workflow to address temporal inefficiency.}
    The traditional debugging workflow requires compilation, deployment, transaction-based state
    setup, and bytecode tracing. Each of these stages incurs significant latency. \textsc{SolQDebug}
    replaces this round trip by performing both parsing and abstract interpretation directly inside
    the Solidity Editor. To support live editing, the Solidity grammar was extended with interactive
    parsing rules tailored for isolated statements, expressions, and control-flow blocks. When the
    developer types or edits code, only the affected region is reparsed incrementally.

    Each parsed statement is inserted into an incremental CFG, and abstract interpretation resumes from
    the edit point. Abstract interpretation with interval domain was used because it provides three key
    properties for edit-time debugging: guaranteed termination through widening, explainable results
    as variable ranges, and millisecond-scale responsiveness. This enables immediate feedback on code
    structure and control flow without compilation or chain interaction.

    \smallskip
    \noindent\textbf{(2) Enabling repeated execution via batch annotations to address iterative inefficiency.}
    The EVM does not support reverting to a prior state without redeploying the contract or replaying
    transactions. Both approaches disrupt iteration. \textsc{SolQDebug} introduces batch annotations
    as a mechanism for symbolic state injection. In essence, this reflects a core debugging activity,
    which involves varying inputs or contract state to observe control-flow outcomes. Rather than
    reconstructing such conditions through live transactions, developers can write annotations at the
    top of the function to define symbolic interval inputs. These inputs are injected before analysis
    begins and rolled back afterward, ensuring test-case isolation.

    This approach brings the debugging workflow closer to the source by making state manipulation
    explicit and reproducible within the code itself. Developers can explore alternative execution
    paths by editing annotations alone without modifying the contract logic or incurring compilation
    and deployment overhead. It effectively decouples symbolic interval input configuration from the
    analysis cycle while preserving the intuitive debugging process developers already follow.

\begin{figure*}[t]
  \centering
  \includegraphics[
    width=0.95\textwidth,
    height=0.35\textheight,
    keepaspectratio
  ]{Fig6.pdf}
  \vspace{0.3cm}
  \caption{\textsc{SolQDebug} architecture}
  \label{fig:solqdebug-arch}
\end{figure*}

\section{The design of SolQDebug}
    \textsc{SolQDebug} is designed to analyze single-contract, single-transaction Solidity functions
    through incremental statement-by-statement processing. As developers write code,
    the system maintains an evolving abstract interpretation of the program, enabling
    immediate feedback on variable values and potential errors without requiring compilation or deployment.
    The following subsections detail the architecture (\S3.1), provide a running example (\S3.2),
    and explain the core mechanisms for parsing (\S3.3) and incremental analysis (\S3.4).

    \subsection{System Architecture}
        Figure~\ref{fig:solqdebug-arch} illustrates the overall architecture of \textsc{SolQDebug}.
        The system accepts either single Solidity statements or batch debug annotations as input,
        processing them through two main modules before producing line-level output:

        \smallskip
        \noindent\textbf{(1) Parsing Module.}
        Each input passes through the \textsc{Context Analyzer}. For source code fragments,
        it identifies existing code structures when needed
        (e.g., an \texttt{if} statement for an \texttt{else} branch).
        For debug annotations, it identifies the target function and extracts its context.
        The \textsc{Interactive Parser}, built on ANTLR~\citep{antlr}, applies an extended grammar with seven specialized
        entry rules that enable parsing of partial constructs. To ensure correctness,
        the system performs syntactic recovery to reconstruct complete source from partial fragments and
        validates it using the official Solidity compiler before proceeding to analysis, ensuring
        semantic consistency and rejecting malformed input early.

        \smallskip
        \noindent\textbf{(2) Analysis Module.}
        The Analysis Module operates through three coordinated components. The \textsc{Incremental CFG
        Builder} maintains a control-flow graph that supports structural updates as statements are added,
        creating nodes and rewiring edges to reflect the evolving structure. The \textsc{Abstract Interpreter}
        analyzes the updated CFG incrementally, reusing previous results and recomputing
        abstract values only for affected program points. The \textsc{Snapshot Manager} preserves
        and restores abstract memory states, ensuring that debug annotations can be modified
        and re-executed without side effects from previous runs.

        \smallskip
        \noindent\textbf{Output.}
        Following analysis, \textsc{SolQDebug} produces a line-level summary showing computed intervals
        for variables affected by each statement, including declarations, assignments, and return values.
        All outputs are mapped to their corresponding source line numbers and displayed inline within
        the editor, providing immediate feedback as developers write and modify code.
    
    \subsection{Running Example}

    To illustrate how the proposed architecture functions in practice, we presented
    a concrete example using the \texttt{burn} function from Figure~\ref{fig:grammar-min}.
    As the developer incrementally constructs this function, the system (1) parses each
    input fragment, (2) updates the control-flow graph, and (3) performs abstract
    interpretation to compute variable intervals. Additionally, when batch debug
    annotations are present, the system re-analyzes the function using the
    annotated symbolic interval input as starting points.
    This example demonstrates these two key analysis modes: incremental source code analysis (\S{}3.2.1)
    and batch annotation analysis (\S{}3.2.2).

        \subsubsection{Incremental Source Code Analysis}

\begin{table}[t!]
  \caption{Incremental inputs for the running example}
  \label{tab:input_code}
  \centering
  \setlength{\tabcolsep}{4pt}
  \renewcommand{\arraystretch}{1.05}
  \ttfamily\footnotesize
  \begin{tabularx}{\columnwidth}{@{}c c X@{}}
    \toprule
    \textbf{Step} & \textbf{Lines of Input Fragment} & \textbf{Fragment} \\
    \midrule
    1 & 11--12 &
      \begin{tabular}[t]{@{}l@{}}
        function burn(uint256 amount) public onlyOwner \{\\
        \}
      \end{tabular} \\
    2 & 12 & uint256 bal = balances[msg.sender]; \\
    3 & 13 & uint256 delta; \\
    4 & 14--15 &
      \begin{tabular}[t]{@{}l@{}}
        if (bal >= amount) \{\\
        \}
      \end{tabular} \\
    5 & 15 & balances[msg.sender] = bal - amount; \\
    6 & 16 & delta = amount; \\
    7 & 18--19 &
      \begin{tabular}[t]{@{}l@{}}
        else \{\\
        \}
      \end{tabular} \\
    8 & 19 & delta = 0; \\
    9 & 21 & totalSupply -= delta; // new input \\
    \bottomrule
  \end{tabularx}
  \rmfamily
\end{table}

Table~\ref{tab:input_code} shows how the developer incrementally constructs the \texttt{burn}
function through nine distinct input steps, each introducing a new code fragment.

\textsc{SolQDebug} accepts two kinds of code fragments as input:

\begin{itemize}
  \item \textbf{Block fragment:} Includes contract and function definitions and control-flow constructs (if/else blocks, while loops).
        When the developer types an opening \texttt{\{}, most editors auto-insert the closing \texttt{\}},
        so the complete block arrives at once
        (e.g., Steps 1, 4, and 7 in Table~\ref{tab:input_code}).

  \item \textbf{Statement fragment:} Includes declarations, assignments, and expressions that
        end with semicolons. Each statement arrives individually as the developer completes typing,
        triggering immediate parsing and analysis
        (e.g., Steps 2, 3, 5, 6, 8, and 9 in Table~\ref{tab:input_code}).
\end{itemize}

\begin{figure*}[t!]
  \centering
  \begin{tikzpicture}[scale=0.85, transform shape,
    node distance=1.5cm and 2.5cm,
    block/.style={rectangle, draw, thick, minimum width=3cm, minimum height=1cm, align=center, font=\footnotesize},
    cond/.style={diamond, draw, thick, aspect=2, minimum width=2cm, minimum height=1cm, align=center, font=\footnotesize},
    join/.style={rectangle, draw, thick, fill=yellow!20, minimum width=2.5cm, minimum height=0.6cm, align=center, font=\footnotesize},
    empty/.style={circle, draw, thick, minimum size=0.8cm, font=\large}
  ]

  % Entry and declarations
  \node[block] (entry) {ENTRY};
  \node[block, below=1cm of entry] (decl) {... declarations ...\\(Steps 2--3)\\env: \{bal: $\top$, delta: $\top$\}};

  % Condition node
  \node[cond, below=1.2cm of decl] (cond) {$bal \geq amount$};

  % Branch paths (simplified)
  \node[block, below left=1.5cm and 2cm of cond] (true) {... intermediate ...\\(Steps 5--6)};
  \node[block, below right=1.5cm and 2cm of cond] (false) {... intermediate ...\\(Step 8)};

  % Leaf nodes
  \node[block, below=1cm of true] (leaf_t) {[Leaf T]\\delta = amount\\env: \{bal:$\top$,\\delta:$\top$\}};
  \node[block, below=1cm of false] (leaf_f) {[Leaf F]\\delta = 0\\env: \{bal:$\top$,\\delta:[0,0]\}};

  % Join point
  \node[block, below=2cm of cond, yshift=-2.5cm] (join) {$\sqcup$ Join Node\\env: \{bal:$\top$,\\delta:$\top$\}};

  % New node with Step 9
  \node[block, below=1cm of join, fill=green!15] (step9) {[New Node]\\totalSupply -= delta\\env: \{totalSupply:$\top$\}};

  % Exit
  \node[block, below=1cm of step9] (exit) {EXIT};

  % Edges
  \draw[->, thick] (entry) -- (decl);
  \draw[->, thick] (decl) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {True} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {False} (false);
  \draw[->, thick] (true) -- (leaf_t);
  \draw[->, thick] (false) -- (leaf_f);
  \draw[->, thick] (leaf_t) -| (join);
  \draw[->, thick] (leaf_f) -| (join);
  \draw[->, thick] (join) -- node[right] {Step 9 inserted} (step9);
  \draw[->, thick] (step9) -- (exit);

  \end{tikzpicture}
  \caption{CFG structure showing Step 9 insertion. Each statement occupies a separate basic node; intermediate nodes along each branch are omitted, showing only the leaf nodes before the join point. The join point node computes the least upper bound of environments from both branches}
  \label{fig:solqdebug-cfg}
\end{figure*}

As the developer types each fragment, \textsc{SolQDebug} incrementally extends the CFG
and recomputes abstract values only for affected program points.
Figure~\ref{fig:solqdebug-cfg} visualizes the CFG structure after Steps 1--8 have been integrated.
To illustrate incremental analysis, we focus on Step~9 (\texttt{totalSupply -= delta;}).
By this point, Steps 1--8 have been analyzed, and their results are already in the CFG.
When Step~9 arrives, it processes the statement as follows:

\begin{enumerate}
  \item The \textsc{Interactive Parser} recognizes \texttt{totalSupply -= delta;} as an assignment.
  \item The \textsc{Incremental CFG Builder} determines the insertion point by examining the edit context and existing CFG.
        In this case, the insertion point is after the join node that merges the if/else branches.
  \item A new node is created for the assignment, and edges are rewired: the join node now
        flows into this new node, which in turn connects to the exit.
  \item The new node receives the environment from the join node, which holds the least upper
        bound (\(\sqcup\)) of environments from both branches.
  \item The \textsc{Abstract Interpreter} performs worklist-based reinterpretation, propagating the updated
        environment from the newly inserted node to all affected nodes in the CFG.
\end{enumerate}

This reinterpretation ensures soundness by propagating each edit's effects to all
affected nodes. Subsequent inputs can then safely reuse the computed abstract
values without re-analyzing the entire program.

        \subsubsection{Batch Annotation Analysis}

\begin{figure}[t]
\begin{lstlisting}[language=Solidity, numbers=left, basicstyle=\ttfamily\small]
uint256 public totalSupply = 1000;

function burn(uint256 amount) public onlyOwner {
    // @Debugging BEGIN
    // @StateVar balances[msg.sender] = [100,200]
    // @LocalVar amount = [50,70]
    // @Debugging END
    uint256 bal = balances[msg.sender];
    uint256 delta;
    if (bal >= amount) {
        balances[msg.sender] = bal - amount;
        delta = amount;
    }
    else {
        delta = 0;
    }
    totalSupply -= delta;
}
\end{lstlisting}
\caption{Burn function with batch annotations}
\label{lst:grammar-batch}
\end{figure}

While incremental analysis supports the edit-test cycle, developers often need
to explore how their program behaves under different testing scenarios.
Batch annotations enable this by letting developers specify test inputs declaratively and
obtain line-level results in a single run.

Figure~\ref{lst:grammar-batch} shows the \texttt{burn} function with batch annotations.
        Annotation blocks are enclosed by \verb|// @Debugging BEGIN| and \verb|// @Debugging END|.
        Each annotation line specifies a variable type (\texttt{@StateVar} for state variables,
        \texttt{@LocalVar} for local variables) and assigns a symbolic interval input, supporting both
        simple variables and nested accesses like \texttt{balances[msg.sender]}.

In this example, we annotate \texttt{balances[msg.sender]} with the interval \([100,200]\)
        and \texttt{amount} with \([50,70]\) to explore how the \texttt{burn} function behaves
        under different balance and amount scenarios. The analysis propagates these intervals through
        the conditional branches, computing \texttt{delta} as \([0,150]\) at the join point and
        reducing \texttt{totalSupply} from \([1000,1000]\) to \([850,1000]\).

        When \textsc{SolQDebug} processes a batch annotation block, it follows this pipeline:

\begin{enumerate}
  \item \textbf{Parse and validate.} Each annotation line is parsed, type-checked, and converted
        to the corresponding abstract domain (e.g., intervals for integers).
  \item \textbf{Save state and overlay.} The unannotated abstract memory is saved, and the annotated
        values replace it for the analysis run.
  \item \textbf{Single-pass analysis.} \textsc{SolQDebug} re-analyzes the pre-built CFG with
        the annotated environment.
  \item \textbf{Restore previous state.} After analysis, the unannotated abstract memory is restored.
\end{enumerate}

Details of these mechanisms appear in \S{}3.3--\S{}3.4.

\subsection{Interactive Parser}

The \textsc{Interactive Parser} extends the official Solidity language grammar~\citep{solgram} with specialized entry rules
that accept partial code fragments during incremental editing.
The parser defines eight specialized entry rules: seven for incremental code edits
and one for batch annotations.

\begin{table}[t]
\centering
\caption{Interactive parser entry rules}
\label{tab:interactive-rules}
\small
\begin{tabular}{@{}c|lp{8cm}@{}}
\toprule
\textbf{Type} & \textbf{Entry Rule} & \textbf{Purpose} \\
\midrule
\multirow{2}{*}[-10pt]{Primary} & interactiveSourceUnit & Top-level declarations: functions, contracts, interfaces, libraries, state variables, pragmas, imports \\
& interactiveBlockUnit & Statements and control-flow skeletons inside function bodies \\
\midrule
\multirow{5}{*}[-8pt]{Continuation} & interactiveEnumUnit & Enum member items added after the enum shell is defined \\
& interactiveStructUnit & Struct member declarations added after the struct shell is defined \\
& interactiveDoWhileUnit & The while tail of a do-while loop \\
& interactiveIfElseUnit & else or else-if branches following an if statement \\
& interactiveCatchClauseUnit & catch clauses following a try statement \\
\bottomrule
\end{tabular}
\end{table}

Table~\ref{tab:interactive-rules} shows the seven rules for Solidity constructs, divided into two categories
that differ in how they interact with existing code:

\begin{itemize}
  \item \textbf{Primary rules} parse constructs that stand alone, requiring no context
        from previous edits.

  \item \textbf{Continuation rules} require context from existing structures. They explicitly
        depend on previously parsed constructs (e.g., \texttt{interactiveIfElseUnit} requires
        a preceding \texttt{if} statement to attach the \texttt{else} branch).
\end{itemize}

This distinction maintains syntactic validity during incremental edits.
\textsc{SolQDebug} validates that continuation rules have their required antecedent structure,
ensuring that the resulting program structure remains well-formed at each step.

For concreteness, we refer to the burn function in Table~\ref{tab:input_code}.
When the developer types the function definition (Step 1), it is parsed by \texttt{interactiveSourceUnit},
which creates a function with an empty body.
Subsequent inputs within the function body are parsed by \texttt{interactiveBlockUnit},
which handles both statement fragments (Steps 2, 3, 5, 6, 8) and block fragments (Step 4).
Step 7 illustrates how continuation rules work: the \texttt{else} block is parsed by
\texttt{interactiveIfElseUnit}, which depends on the preceding \texttt{if} from Step 4
(see Appendix~\ref{appendix:interactive-grammar}).

Beyond these seven interactive rules for Solidity constructs, the parser includes
a specialized \texttt{debugUnit} rule for batch annotations.
The grammar defines three annotation types:

\begin{itemize}
  \item \textbf{GlobalVar} assigns values to global variables such as msg.sender or block.timestamp
  \item \textbf{StateVar} assigns values to contract state variables, supporting nested access patterns like balances[msg.sender] or user.balance
  \item \textbf{LocalVar} assigns values to function parameters
\end{itemize}

The complete grammar specification appears in Appendix~\ref{appendix:interactive-grammar},
with the full ANTLR4 implementation available at~\citep{solqrule}.

    \subsection{Incremental CFG Construction and Abstract Interpretation}

Incremental CFG construction maintains a control-flow graph that evolves as developers insert new statements.
Rather than rebuilding from scratch, our approach modifies the graph in place.
The following first describes the hierarchical organization of CFGs at the contract and function levels (\S3.4.1),
then explains how individual statements are incrementally spliced into the function-level CFG (\S3.4.2),
how the insertion site is determined (\S3.4.3), and how reinterpretation propagates abstract values
only through affected regions (\S3.4.4).

Our CFG consists of the following node types:
\begin{itemize}
  \item \textsc{entry node}: The unique entry point where execution begins. Contract-level CFGs have a contract entry, and function-level CFGs have a function entry.
  \item \textsc{state variable node}: A contract-level node that holds all state variable declarations. Since state variables have no branching logic, they are collected into a single node.
  \item \textsc{basic node}: Holds exactly one statement (e.g., a variable declaration, an assignment, or a function call).
  \item \textsc{condition node}: Represents branching constructs such as \texttt{if}, \texttt{else if}, \texttt{while}, \texttt{require}/\texttt{assert}, and \texttt{try}.
  \item \textsc{join node}: Merges control flow from multiple branches (e.g., \textsc{if join}, \textsc{else-if join}).
  \item \textsc{fixpoint evaluation node} (\(\phi\)): The loop join point used for widening and narrowing during fixpoint computation (\S3.4.3).
  \item \textsc{loop exit node}: The false branch that exits a loop when the guard condition fails.
  \item \textsc{return node}: A statement node whose outgoing edge is immediately rewired to the function's unique \textsc{return exit}.
  \item \textsc{error exit}: The function's unique exceptional exit (targets the exceptional path via \texttt{revert}, \texttt{require}, or \texttt{assert} failures).
  \item \textsc{exit node}: The unique normal exit point where execution terminates successfully. Contract-level CFGs have a contract exit, and function-level CFGs have a function exit.
\end{itemize}

\subsubsection{CFG Hierarchy}

\textsc{SolQDebug} organizes control flow at two levels. At the contract level, a
\textsc{ContractCFG} sequences state variable initializations, the constructor, and function
definitions. This ordering reflects how Solidity deploys contracts. State variables are
initialized first, then the constructor executes and may modify those state variables.
Function definitions receive the environment that results from constructor execution.

At the function level, each \textsc{FunctionCFG} represents control flow starting from a
function's entry point. When a function declares modifiers, the function body is spliced
into the modifier's control flow at the placeholder (\texttt{\_}) position. When a function invokes another function, the callee's \textsc{FunctionCFG}
is incorporated as part of the caller's control flow graph. The complete CFG hierarchy
structures are shown in Appendix~\ref{appendix:cfg-patterns}.

\subsubsection{Statement-Local, Incremental Construction}

Having described the hierarchical organization of CFGs, we now focus on how individual
statements are incrementally spliced into the function-level CFG. Each insertion operates
at the \textsc{current node}, the insertion point for new statements. The following statement
types create their corresponding CFG structures:

\begin{itemize}
  \item \textbf{Simple statements} are spliced between the current node and its successors, creating a single
        \textsc{basic node}. This includes variable declarations, assignments, function calls, and expression statements.
        The environment flows sequentially through the new node, updated by the statement's semantics
        (Figure~\ref{fig:new-simple-statement}).

  \item \textbf{If statement} creates a \textsc{condition node}, true/false \textsc{basic nodes}, and an
        \textsc{if join}. The environment propagates from the current node to the condition, then branches
        to the true/false arms with the environment refined by the branch condition, and merges at the join
        node via the least upper bound operation (Figure~\ref{fig:new-if}).

  \item \textbf{Else-if clause} replaces the preceding false branch with a new \textsc{condition node}
        and its own join, which then connects to the outer \textsc{if join}. The environment flows through
        the else-if condition, branches to its true/false arms with refinement, merges at the else-if join,
        and continues to the outer join (Figure~\ref{fig:new-else-if}).

  \item \textbf{Else clause} replaces the false branch node of the preceding \texttt{if}/\texttt{else if}
        with a new else node, which connects to the \textsc{if join}. The environment is refined by the
        negated condition and merges at the join (Figure~\ref{fig:new-else}).

  \item \textbf{While loop} creates a \textsc{fixpoint evaluation node} $\phi$, a \textsc{condition node},
        a loop body node, and a \textsc{loop exit node}. The body connects back to $\phi$ for fixpoint iteration.
        The environment propagates through $\phi$ to the condition, then branches to the body or exit with the
        environment refined by the loop guard, with the body flowing back to $\phi$ until convergence
        (Figure~\ref{fig:new-while}).

  \item \textbf{Break statement} is inserted in the loop body with its outgoing edge redirected to the
        \textsc{loop exit node} (Figure~\ref{fig:new-break}).

  \item \textbf{Continue statement} is inserted in the loop body with its outgoing edge redirected to the
        loop's $\phi$ node (Figure~\ref{fig:new-continue}).

  \item \textbf{Return statement} is inserted with its edge rewired to the function's unique \textsc{return exit},
        detaching original successors. The environment flows directly to the return exit (Figure~\ref{fig:new-return}).

  \item \textbf{Require statement} creates a \textsc{condition node} with the true edge connecting to a
        continuation node and the false edge pointing to the \textsc{error exit}. The environment propagates
        with refinement based on the predicate to the continuation or error exit (Figure~\ref{fig:new-require}).
\end{itemize}

These construction patterns enable \textsc{SolQDebug} to build the CFG incrementally
as the user types each statement, with environment updates propagating only through affected nodes.
Representative CFG construction patterns are provided in Appendix~\ref{appendix:cfg-patterns}.
The complete implementation supports all Solidity statements~\citep{solqimpl}.


\subsubsection{Line-to-Node Indexing for Incremental Insertion}

\begin{table}[t!]
\centering
\caption{Line-to-node index mapping by statement type}
\label{tab:line-mapping}
\small
\begin{tabular}{@{}lll|lll@{}}
\toprule
\multicolumn{3}{c|}{\textbf{Simple Statements}} & \multicolumn{3}{c}{\textbf{Compound Statements}} \\
\textbf{Statement} & \textbf{Maps Start} & \textbf{Maps End} & \textbf{Statement} & \textbf{Maps Start} & \textbf{Maps End} \\
 & \textbf{Line To} & \textbf{Line To} &  & \textbf{Line To} & \textbf{Line To} \\
\midrule
\texttt{simple statement} & basic node & (none) & \texttt{if} & condition node & join node \\
 & & & \texttt{else if} & condition node & join node \\
\texttt{break} & basic node & (none) & \texttt{else} & else node & join node \\
\texttt{continue} & basic node & (none) & \texttt{while} & condition node & exit node \\
\texttt{return} & return node & (none) & & & \\
\texttt{require} & condition node & (none) & & & \\
\bottomrule
\end{tabular}
\end{table}

The key challenge in incremental CFG construction is determining where to insert each new node.
Traditional CFG construction processes complete programs sequentially, building the
entire graph in a single pass. In contrast, \textsc{SolQDebug} must handle partial code edits
that specify only target line numbers. Since CFG edges encode control flow rather than source positions,
we cannot determine where an edit belongs without additional context.
To enable incremental insertion, we maintain a line-to-node index during
construction. Table~\ref{tab:line-mapping} summarizes how statement types map lines to nodes.

\texttt{Simple statements} index only their start line. Most statements map to a basic node, though return maps to a return node and require maps to a condition node.
Compound statements index both start and end lines. Conditionals (\texttt{if} and \texttt{else if}) map their start line to a condition node and end line to a join node, while \texttt{else} maps its start line to an else node and end line to the join node. Loops (\texttt{while}) map their start line to a condition node and end line to an exit node.

\begin{algorithm}[t!]
\caption{Dependent-Context Insertion}
\label{alg:get-branch-context}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, line-to-node index $M$, current line $L$
\State \textbf{Output:} Condition node $c$
\Function{GetBranchContext}{$G, M, L$}
  \State $queue \gets \textsc{FindJoinNode}(M, L)$ \Comment{find join node at or before line $L$}
  \If{$queue=\emptyset$} \State \textbf{error} ``No join node found at or before line $L$'' \EndIf
  \State $visited \gets \emptyset$

  \While{$queue\neq\emptyset$} \Comment{BFS through predecessors}
    \State $n \gets \textsc{Dequeue}(queue)$
    \If{$n\in visited$} \textbf{continue} \EndIf
    \State $visited \gets visited\cup\{n\}$

    \If{$\textsc{IsCond}(G, n)$ \textbf{and} $\textsc{CondType}(n)\in\{\texttt{if},\texttt{else\_if}\}$}
      \State \Return $n$
    \EndIf

    \For{$p\in\textsc{Pred}(G, n)$}
      \If{$p\notin visited$} \State $\textsc{Enqueue}(queue,p)$ \EndIf
    \EndFor
  \EndWhile

  \State \textbf{error} ``No matching condition node found''
\EndFunction
\end{algorithmic}
\end{algorithm}

This indexing scheme enables Algorithms~\ref{alg:get-branch-context} and~\ref{alg:get-insertion-site} to locate insertion sites efficiently.
These algorithms handle the representative statement types shown in Table~\ref{tab:line-mapping}.
Both algorithms rely solely on the line-to-node index without mutating the graph.

The choice between these algorithms depends on whether the statement can exist independently:
\begin{itemize}
  \item \textbf{Dependent contexts:} \texttt{else}/\texttt{else if} must attach to a preceding \texttt{if}/\texttt{else if} condition. Algorithm~\ref{alg:get-branch-context} traverses CFG predecessors to find the condition node.
  \item \textbf{Independent contexts:} All other statements can exist independently. Algorithm~\ref{alg:get-insertion-site} uses a successor-first strategy, leveraging the fact that successors are already inserted and have complete CFG structure.
\end{itemize}

\noindent\textbf{Algorithm~\ref{alg:get-branch-context}: Dependent-Context Insertion.}
Dependent contexts (\texttt{else}/\texttt{else if}) cannot exist independently and must attach to a preceding
\texttt{if}/\texttt{else if} condition node. The algorithm proceeds as follows:
\begin{itemize}
  \item \textbf{Initialization (Lines 4--8):} Uses the line-to-node index $M$ to retrieve the join node at or before line \(L\), initializing the Breadth-First Search (BFS) queue. This node serves as the starting point for backward traversal to find the preceding conditional. If no node is found, the dependent context is invalid (Lines 5--7). The visited set is initialized to track explored nodes (Line 8).
  \item \textbf{BFS traversal (Lines 9--22):} Performs BFS through CFG predecessors to find the matching condition node of type \texttt{if} or \texttt{else\_if}. The BFS ensures we find the \emph{nearest} enclosing condition.
  \item \textbf{Error handling (Line 23):} Reports an error if no matching condition is found.
\end{itemize}

\begin{algorithm}[t!]
\caption{Independent-Context Insertion}
\label{alg:get-insertion-site}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, line-to-node index $M$, insertion position at line $L$
\State \textbf{Output:} Insertion-site node $A$
\Function{GetInsertionSite}{$G, M, L$}
  \State $s \gets \textsc{FindPostNode}(M, L)$ \Comment{find first node after line $L$}

  \If{$\textsc{IsLoopExit}(G, s)$ \textbf{or} $\textsc{IsJoin}(G, s)$} \Comment{closing a loop or selection}
    \State $n \gets \textsc{FindPreviousNode}(M, L)$ \Comment{condition if exists, else last node}
    \If{$\textsc{IsCond}(G, n)$}
      \State \Return $\textsc{BranchBlock}(n,\mathsf{true})$ \Comment{insert in TRUE branch}
    \Else
      \State \Return $n$
    \EndIf

  \Else \Comment{basic successor}
    \State $pred \gets \textsc{Pred}(G, s)$
    \If{$|pred|=1$} \State \Return the unique element of $pred$
    \Else \State \textbf{error} ``Basic successor must have exactly 1 predecessor''
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:get-insertion-site}: Independent-Context Insertion.}
For independent contexts, which include all statements except \texttt{else}/\texttt{else if}, we use a successor-first strategy. By identifying the post node---the next statement by line number---we determine the correct insertion point based on its CFG structure.
This approach handles all statement types uniformly:
\begin{itemize}
  \item \textbf{Find post node (Line 4):} \textsc{FindPostNode}(\(M, L\)) retrieves the first node after line \(L\) from the line-to-node index.
  \item \textbf{Loop-exit/join case (Lines 5--11):} If the post node \(s\) is a loop-exit or join node, we search backward using \textsc{FindPreviousNode}(\(M, L\)) to find the previous node. This returns a condition node if present (loop condition node or \texttt{if}), otherwise the last node before \(L\).
    \begin{itemize}
      \item If it is a condition node, we return its TRUE branch to place the new statement inside the construct (Line 8).
      \item Otherwise, we return the node itself (Line 10).
    \end{itemize}
  \item \textbf{Basic post node (Lines 12--19):} Otherwise, \(s\) is a basic statement node (Line 12). The CFG predecessors are retrieved and verified to be exactly one (Lines 13--15), which must hold by construction since conditionals are created with their join nodes and loops are created with their exit nodes. Any other count indicates a malformed CFG (Lines 16--18).
\end{itemize}

        \subsubsection{Abstract Interpretation for Incremental Analysis}\label{sec:impl}
\textsc{SolQDebug} provides instant feedback on source code edits by propagating updates only along affected CFG paths, avoiding full re-analysis. When the user inserts statements, new nodes are spliced into the CFG. Incremental reinterpretation then propagates updates from these insertion points as seed nodes.
While for debug annotations, \textsc{SolQDebug} performs full interpretation from the function entry node, ensuring all inspection points receive complete abstract states.
Algorithm~\ref{alg:reinterpret} performs incremental interpretation by propagating abstract states
through a worklist-based dataflow analysis. When encountering loop condition nodes, it delegates to
Algorithm~\ref{alg:fixpoint} for loop fixpoint computation.

\begin{algorithm}[t!]
\caption{Incremental Interpretation}
\label{alg:reinterpret}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, seed set $S$
\State \textbf{Output:} Environments updated along forward-reachable paths from $S$
\Function{IncrementalInterpretation}{$G, S$}
  \State $wl\gets\langle\rangle$; \quad $inq\gets\emptyset$; \quad $out\gets$ output map
  \ForAll{$s\in S$}
    \If{$\neg\textsc{IsSink}(G, s)\ \land\ s\notin inq$} \State $wl.\textsf{enqueue}(s)$; \quad $inq\gets inq\cup\{s\}$ \EndIf
  \EndFor

  \While{$wl\neq\langle\rangle$}
    \State $n \gets wl.\textsf{dequeue}()$; \quad $inq\gets inq\setminus\{n\}$
    \State $\hat{\sigma}_{\mathrm{in}}\gets \bigsqcup_{p\in\textsc{Pred}(G, n)} \textsc{RefineByCondition}(p,n)$ \Comment{join predecessors with path refinement}

    \If{$\textsc{IsLoopHeader}(G, n)$}
       \State $exit \gets \textsc{Fixpoint}(G, n)$ \Comment{compute loop fixpoint (Algorithm~\ref{alg:fixpoint})}
       \ForAll{$s \in \textsc{Succ}(G, exit)$}
         \If{$\neg\textsc{IsSink}(G, s)\ \land\ s\notin inq$} \State $wl.\textsf{enqueue}(s)$; \quad $inq\gets inq\cup\{s\}$ \EndIf
       \EndFor
       \State \textbf{continue}
    \EndIf

    \State $\hat{\sigma}_{\mathrm{out}}\gets \textsc{Transfer}(n,\hat{\sigma}_{\mathrm{in}})$
    \If{$\hat{\sigma}_{\mathrm{out}}\neq out[n]$}
       \State $\Env(n)\gets \hat{\sigma}_{\mathrm{out}}$; \quad $out[n]\gets \hat{\sigma}_{\mathrm{out}}$
       \ForAll{$s \in \textsc{Succ}(G, n)$}
         \If{$\neg\textsc{IsSink}(G, s)\ \land\ s\notin inq$} \State $wl.\textsf{enqueue}(s)$; \quad $inq\gets inq\cup\{s\}$ \EndIf
       \EndFor
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:reinterpret}: Incremental Interpretation.}
\begin{itemize}
  \item \textbf{Worklist and output cache initialization (Line 4):} Initialize empty worklist $wl$, in-queue set $inq$ to track enqueued nodes, and output map $out$ to store previous node outputs for change detection.

  \item \textbf{Seed node initialization (Lines 5--9):} Enqueue all seed nodes $s \in S$, which mark insertion points for incremental edits or function entry for batch annotations. Sink nodes (exit, error, return) with no successors are filtered out.

  \item \textbf{Worklist iteration (Lines 10--31):} The while loop processes nodes until the worklist is empty. Each iteration performs the following steps for the dequeued node $n$:

  \item \textbf{Incoming environment computation (Lines 11--12):} Compute incoming environment $\hat{\sigma}_{\mathrm{in}}$ by joining outputs from all predecessors. For condition nodes, \textsc{RefineByCondition} narrows operand intervals based on the edge truth label (true/false branch), pruning infeasible paths.

  \item \textbf{Loop condition node delegation (Lines 13--21):} When encountering a loop condition node, delegate to Algorithm~\ref{alg:fixpoint} to compute the loop fixpoint. After fixpoint converges, enqueue the loop-exit node's successors to continue analysis beyond the loop.

  \item \textbf{Transfer function (Line 22):} Apply the abstract transfer function to node $n$, computing output environment $\hat{\sigma}_{\mathrm{out}}$ by interpreting statements (assignments, calls, etc.) using interval arithmetic and domain operations.

  \item \textbf{Change detection and propagation (Lines 23--30):} Compare $\hat{\sigma}_{\mathrm{out}}$ with the previously stored output $out[n]$. Only if changed, update node environment and the stored output, then enqueue successors. This ensures fixpoint termination by stopping propagation when environments stabilize.
\end{itemize}

\begin{algorithm}[t!]
\caption{Loop Fixpoint with Adaptive Widening}
\label{alg:fixpoint}
\begin{algorithmic}[1]
\State \textbf{Input:} CFG $G$, loop condition node $h$
\State \textbf{Output:} Loop exit node with converged environment
\Function{LoopFixpoint}{$G, h$}
  \State $L \gets \textsc{LoopNodes}(G, h)$; \quad $start \gets \bigsqcup\{\Env(p)\mid p\in\textsc{Pred}(G, h)\setminus L\}$
  \State $\tau \gets \textsc{EstimateIterations}(h, start)$ \Comment{annotation-aware threshold}
  \State $vis[\cdot]\gets 0$; \quad $in[h]\gets start$

  \State \textbf{// Widening phase}
  \State $wl\gets \langle h\rangle$
  \While{$wl\neq\langle\rangle$}
    \State $n\gets wl.\textsf{dequeue}()$; \quad $vis[n]\gets vis[n]+1$
    \If{$in[n] = \bot$} \Comment{compute input if not initialized}
       \State $in[n] \gets \bigsqcup_{p\in\textsc{Pred}(G, n)\cap L} \textsc{RefineByCondition}(p,n)$
    \EndIf
    \State $\hat{o}_{\text{raw}}\gets \textsc{Transfer}(n,in[n])$
    \If{$\textsc{IsFixpointEvalNode}(n)\ \land\ vis[n] > \tau$}
       \State $\hat{o}\gets \textsc{Widen}(out[n],\hat{o}_{\text{raw}})$ \Comment{widen at fixpoint eval node after $\tau$ visits}
    \Else \State $\hat{o}\gets out[n]\sqcup \hat{o}_{\text{raw}}$
    \EndIf

    \If{$\hat{o} = out[n]$} \State $out[n]\gets \hat{o}$; \textbf{ continue} \Comment{fixpoint reached, skip propagation}
    \EndIf

    \State $out[n]\gets \hat{o}$
    \ForAll{$s \in \textsc{Succ}(G, n) \cap L$}
      \State $wl.\textsf{enqueue}(s)$
    \EndFor
  \EndWhile

  \State \textsc{NarrowingPhase}($L$) \Comment{standard descending iteration}

  \State $exit \gets \textsc{FindLoopExit}(G, h)$
  \State $\Env(exit) \gets \bigsqcup_{p\in\textsc{Pred}(G, exit)} \textsc{RefineByCondition}(p, exit)$ \Comment{join with false-branch pruning}
  \State \Return $exit$
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:fixpoint}: Loop Fixpoint with Adaptive Widening.}
While Algorithm~\ref{alg:reinterpret} handles general incremental propagation,
loop analysis with the interval domain faces a well-known precision challenge.
To guarantee termination, widening operators must be applied after a bounded number of iterations,
often causing intervals to expand to $\top$ or $[0, \infty]$ even when the actual loop bounds are finite.
However, Solidity's properties create opportunities for mitigation.
Gas costs limit loop complexity, and loop conditions commonly depend on simple values
such as array lengths, mapping sizes, or bounded counters.

Algorithm~\ref{alg:fixpoint} computes loop fixpoints using annotation-aware adaptive widening to address this challenge.
The key innovation is that \textsc{EstimateIterations} analyzes loop conditions to compute an adaptive threshold $\tau$ that defers widening. When debug annotations provide precise interval bounds for condition operands such as array lengths or parameter values, the analyzer raises $\tau$ to delay widening and preserve precision. The fixpoint iteration terminates when all variables converge, meaning node outputs equal their previously stored values, ensuring soundness.

\begin{itemize}
  \item \textbf{Identify loop nodes and pre-loop environment (Line 4):} Collect all nodes within the loop body. Compute $start$ by joining environments from all loop-entry predecessors, specifically those from outside the loop rather than from within the loop body itself.

  \item \textbf{\textsc{EstimateIterations} (Line 5):} Evaluate both operands of the loop condition in the pre-loop environment $start$. For comparison operators ($<, \le, >, \ge$), compute adaptive threshold $\tau$ as follows:
  \begin{itemize}
    \item When both operands evaluate to concrete constant intervals, $\tau$ is computed as the difference between operand bounds. For example, given \texttt{i < array.length} where \texttt{i = [0,0]} and \texttt{array.length = [10,10]}, $\tau = 10 - 0 = 10$. The operands may be variables or complex expressions, but both must reduce to constant intervals through annotation-provided values.
    \item When either operand cannot be reduced to a constant interval, $\tau$ defaults to 1, allowing one iteration to initialize node environments before widening is applied.
  \end{itemize}

  \item \textbf{Initialization (Line 6):} Initialize visit counts $vis$ to track iterations and node input environments $in$, setting $in[h] \gets start$ for the loop condition node.

  \item \textbf{Widening phase (Lines 9--27):} Perform fixpoint iteration with worklist-based propagation. Each iteration performs the following steps:
  \begin{itemize}
    \item Dequeue node and increment visit count (Line 10); compute incoming environment if not initialized (Lines 11--13).
    \item Apply transfer function to compute raw output (Line 14).
    \item Apply adaptive widening (Lines 15--19): use widening operator if visit count exceeds $\tau$ (Line 16), otherwise use join (Line 18).
    \item Check for convergence (Lines 20--22): if output unchanged, skip propagation (Line 21); otherwise, store output (Line 23) and enqueue successors (Lines 24--26).
  \end{itemize}

  \item \textbf{Narrowing phase and exit node (Lines 28--31):} Apply standard narrowing using descending iteration with narrowing operator at fixpoint evaluation nodes to refine over-approximations from widening (Line 28). Then compute the exit node environment (Lines 29--30) by joining predecessor outputs where the loop condition node's false-branch is refined by the negated loop condition. Return the exit node with its computed environment (Line 31).
\end{itemize}

\smallskip
\noindent\textbf{Abstract Interpretation Framework.}
Our approach builds upon abstract interpretation frameworks for Solidity smart contracts~\citep{flow,DBM}.
\textsc{SolQDebug} computes sound over-approximations of variable ranges using interval domains
for integer and boolean types ($\widehat{\mathbb{Z}}_N, \widehat{\mathbb{U}}_N$), set abstractions
for addresses, and on-demand materialization for composite types such as arrays, mappings, and structs.
Unlike prior work focusing on invariant generation~\citep{DBM} or information flow analysis~\citep{flow}, we target interactive debugging with incremental refinement.
The complete formal semantics (Tables~\ref{tab:conc-denot} and~\ref{tab:abs-denot}) are in Appendix~\ref{app:semantics}.

\FloatBarrier

% SECTION 3.5 MOVED TO APPENDIX A
% (Former subsection: Design of the Abstract Interpretation Framework for Solidity)
% CONTENT MOVED TO APPENDIX A

\section{Evaluation}
To evaluate the benefits of \textsc{SolQDebug} in real-world development scenarios,
we structure our empirical analysis around three key questions:

\begin{itemize}
  \item \textbf{RQ1 -- Responsiveness}:\;%
        How much does \textsc{SolQDebug} reduce debugging latency compared to Remix?

  \item \textbf{RQ2 -- Impact of Annotation Patterns on Precision}:\;%
        How should developers structure annotations to improve precision in
        arithmetic operations involving multiplication and division?

  \item \textbf{RQ3 -- Loops}:\;%
        How does \textsc{SolQDebug}'s analysis approach affect precision in loop structures?
\end{itemize}

To answer these questions, we conducted experiments under controlled conditions.

\subsection{Experimental Setup}
\textsc{SolQDebug} was evaluated on single-contract, single-transaction functions
to validate the contributions of incremental CFG construction and
annotation-guided abstract interpretation, with multi-contract analysis
as future work.

\smallskip
\noindent\textbf{Experimental Setting.}
The evaluation environment consists of an 11th Gen Intel\textregistered{} Core\texttrademark{}
i7-11390H CPU at 3.40GHz with 16.0~GB RAM, running Windows 10 (64-bit).
\textsc{SolQDebug} is implemented in Python~3.10 and operates directly on Solidity
source code without requiring compilation or deployment, using the ANTLR4-based
parser described in Section~3.

\smallskip
\noindent\textbf{Dataset Collection.}
The dataset was derived from DAppSCAN~\citep{dappscan}, a large-scale benchmark containing
3,344 Solidity contracts compiled with version \texttt{>=0.8.0}. To ensure representative
coverage across contract sizes, contracts smaller than 4~KB (2,142 samples) were first excluded,
which typically contain minimal logic unsuitable for debugging analysis. From the remaining
1,202 contracts, approximately 10\% were sampled from each of three size brackets:
\begin{itemize}
  \item 4--10~KB (735 contracts): 70 samples
  \item 11--20~KB (304 contracts): 30 samples
  \item Over 20~KB (163 contracts): 20 samples
\end{itemize}
yielding 120 candidate contracts. From these candidates, two filtering criteria were then applied: (1)~excluding functions with multi-contract
interactions such as accessing variables or invoking functions from other contracts,
as the analysis focuses on single-contract scenarios, and (2)~excluding logic-free
functions that contain only assignments or return statements.

After applying these filters, representative functions were selected based on three dimensions of debugging complexity:
\begin{itemize}
  \item \textbf{Computational complexity}---complex arithmetic patterns with
        chained computations across multiple statements, making value ranges
        hard to predict manually.
  \item \textbf{Data structure complexity}---structs with multiple fields, nested
        mappings, dynamic arrays, and mapping-to-struct patterns.
  \item \textbf{Control flow complexity}---loops with varying termination conditions,
        nested conditionals, and modifier-based access control.
\end{itemize}
Based on these criteria, we select 30 representative functions for evaluation from diverse DeFi scenarios including token transfers
with custom logic, staking/vesting mechanisms, liquidity pool operations, oracle
data processing, and marketplace transactions.
Table~\ref{tab:benchmark-dataset} lists all 30 benchmark contracts with their
source files, target functions, and line counts.

\input{benchmark_table}

The following presents the findings for each research question.

\subsection{RQ1 - Responsiveness}
To evaluate responsiveness, \textit{debugging latency} was measured, defined as the time
required to step through the execution of a function line-by-line.
For Remix IDE, this corresponds to the duration from opening the debugger to
stepping through the entire execution using the "step forward" button. For \textsc{SolQDebug}, it
represents the time from a code modification to the display of updated variable information.

Since Remix IDE lacks built-in automated benchmarking capabilities, \texttt{remix\_benchmark}~\citep{remix_bench}
was developed, a Selenium~\citep{selenium}-based automation framework
that programmatically controls the Remix web interface, automating compilation, deployment, and step-through debugging.

Unlike Remix's concrete execution model, which requires stepping through every bytecode
instruction for each test input, \textsc{SolQDebug} uses AI with
interval domain (Section~\ref{sec:impl}) that operates directly on the Solidity AST.
Rather than enumerating concrete values one by one, the abstract interpreter represents
inputs as intervals and computes abstract states over those intervals, analyzing all possible
behaviors in a single pass without blockchain deployment. With this interval-based approach,
\textsc{SolQDebug} maintains consistent latency regardless of test-case width \(\Delta\),
which specifies the width of each symbolic interval input in debug annotations. In contrast, Remix must
execute each concrete input value separately, so its latency scales linearly with the number
of test inputs.

Although \textsc{SolQDebug} is designed for interactive use within a Solidity editor, all
experiments simulate this behavior in a controlled scripting environment. For each function,
a sequence of incremental edits and annotations was reconstructed that mimic realistic developer
activity. These fragments are streamed into the interpreter to measure latency and interval
growth under reproducible conditions.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{Fig9.pdf}
  \caption{Debugging latency comparison between \textsc{SolQDebug} and Remix across varying
  ByteOp counts and test-case widths \(\Delta\). \textsc{SolQDebug} maintains consistent
  sub-second latency regardless of function complexity or symbolic interval input width, while Remix's
  latency scales linearly with both dimensions.}
  \label{fig:rq1-responsiveness}
\end{figure}

30 functions were evaluated across 4 test-case widths \(\Delta \in \{0, 2, 5, 10\}\), yielding
120 total measurements for \textsc{SolQDebug}. For Remix, each function was measured once per
\(\Delta\) value to demonstrate the linear scaling behavior.
Figure~\ref{fig:rq1-responsiveness} illustrates the latency comparison across these dimensions.

For Remix, the debugging latency ranged from 25.1 to 124.6 seconds (median: 53.0s), reflecting
the time required to step through bytecode operations in the debugger, with latency
scaling linearly with test-case width as each additional input value requires a separate
transaction execution and complete bytecode step-through.
In contrast, \textsc{SolQDebug} completed analysis in 0.03--5.09 seconds (median: 0.15s)
across all 120 measurements. \textsc{SolQDebug}'s latency remains nearly constant
regardless of test-case width, as AI analyzes all
input combinations symbolically in a single pass. This results in a median speedup of approximately
350$\times$ over Remix for pure debugging time. In practice, Remix users also incur additional
overhead from compilation, deployment, and state initialization, further increasing total debugging
time. \textsc{SolQDebug} eliminates these preparatory steps entirely, enabling immediate feedback
during code editing.

\medskip
\noindent\fbox{%
\begin{minipage}{0.96\linewidth}
\textbf{Answer to RQ1:}
\textsc{SolQDebug} achieves sub-second debugging latency (median: 0.15s), providing
approximately 350$\times$ faster line-by-line variable inspection compared to Remix's
bytecode step-through (median: 53.0s). Unlike Remix, whose latency scales linearly with
input space size, \textsc{SolQDebug}'s performance through abstract interpretation does not depend on
test-case width. Including compilation and deployment overhead further increases Remix's total latency.
\end{minipage}%
}

\subsection{RQ2 - Impact of Annotation Patterns on Precision in Complex Arithmetic Operations}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{Fig10.pdf}
  \caption{
F90 (90th percentile of interval inflation) for \texttt{Lock::pending} under \textsc{overlap} and \textsc{diff} annotation patterns.
As input width ($\Delta$) increases, \textsc{overlap} achieves progressively tighter precision (F90: 12.0 $\rightarrow$ 4.8),
while \textsc{diff} maintains near-constant inflation (F90 $\approx$ 13--14).}
  \label{fig:rq2-lock}
\end{figure}

Real-world smart contracts frequently use complex arithmetic operations involving multiplication and division
to compute financial quantities such as rewards, fees, and vesting schedules.
These operations inherently amplify interval widths during AI
due to the combinatorial nature of interval arithmetic.
Understanding how annotation structure influences precision in such contexts is critical for practical adoption
of \textsc{SolQDebug}.

To investigate this, the \texttt{pending} function from \texttt{Lock.sol} in the benchmark dataset was examined. The function uses complex arithmetic operations involving multiplication and division. Multiplication is critical: in interval arithmetic, it computes the Cartesian product of endpoint combinations $\{a_{\min} \times b_{\min}, a_{\min} \times b_{\max}, a_{\max} \times b_{\min}, a_{\max} \times b_{\max}\}$. Consequently, when operand intervals are disjoint, this combinatorial expansion generates significantly wider output ranges.

To assess this effect, two annotation strategies were evaluated under varying input widths $\Delta \in \{1, 3, 6, 10\}$.
In the \textsc{overlap} style, all input variables share a common base range (e.g., $[100, 100+\Delta]$).
In the \textsc{diff} style, each variable occupies a distinct range (e.g., $[100, 100+\Delta]$, $[300, 300+\Delta]$,
$[500, 500+\Delta]$). F90 was measured, the 90th percentile of the inflation factor
$F = \frac{\text{exit\_width}}{\text{input\_width}}$.

As shown in Figure~\ref{fig:rq2-lock}, the \textsc{overlap} strategy consistently produces tighter bounds: as $\Delta$ increases from 1 to 10, F90 decreases from 12.0 to 4.8, indicating that wider inputs lead to proportionally smaller relative growth. In contrast, the \textsc{diff} strategy maintains nearly constant inflation (F90 $\approx$ 13--14) regardless of input width. This difference arises from interval multiplication semantics: when annotations align operands to overlapping ranges, the extreme products remain closer to the midpoint, limiting excessive interval expansion. Conversely, disjoint ranges maximize the distance between endpoint combinations, causing output intervals to span unnecessarily large ranges.

Moreover, similar patterns were observed in other contracts from the benchmark dataset that use multiplication or division in their arithmetic.
These include reward computations (GovStakingStorage\_c), fee calculations (GreenHouse\_c, HubPool\_c), vesting schedules (LockupContract\_c), and proportional payouts (ThorusBond\_c).
Across these contracts, overlapping annotations consistently yield tighter precision than disjoint ranges, demonstrating that developers can significantly improve analysis precision by choosing overlapping rather than disjoint annotations.

\medskip
\noindent\fbox{%
\begin{minipage}{0.96\linewidth}
\textbf{Answer to RQ2:}
For real-world contracts using multiplication or division, overlapping annotations yield significantly lower interval inflation than disjoint annotations, due to interval multiplication's combinatorial nature. Developers should prefer overlapping annotation patterns to improve analysis precision in such contexts.
\end{minipage}%
}

\subsection{RQ3 - Loops}

To evaluate the effectiveness of annotation-guided adaptive widening for loop analysis,
the five loop-containing functions from the benchmark dataset (Table~\ref{tab:benchmark-dataset}) were analyzed:
\texttt{updateUserInfo} (AOC\_BEP), \texttt{\_addActionBuilderAt} (Balancer), \texttt{revokeStableMaster} (Core), \texttt{getTotalDeposit} (TimeLockPool), and \texttt{\_removeFromTokens} (AvatarArtMarketPlace).
These functions exhibit four distinct patterns that demonstrate varying levels of precision under this approach.

\smallskip
\noindent\textbf{Pattern 1: Constant-Bounded Loops with Simple Updates.}
When loop conditions reference only constants and the loop body contains only simple assignments,
\textsc{EstimateIterations} computes precise thresholds without annotations.
For example, \texttt{updateUserInfo} (AOC\_BEP) uses \texttt{for (uint256 i = 1; i <= 4; i++)}
with $\tau = 4$ computed from the constant bound.
The small constant bound and simple updates allow convergence without triggering widening.
The analysis produces precise interval \texttt{userInfo[account].level} $\in [1,4]$.

\smallskip
\noindent\textbf{Pattern 2: Annotation-Enabled Convergence.}
When loop bounds depend on dynamic values but the loop body performs only simple updates,
annotations enable precise convergence.
\texttt{\_addActionBuilderAt} (Balancer) uses \texttt{for (uint8 i = 0; i < additionalCount; i++)}
where \texttt{additionalCount} is computed from function inputs.
With appropriate annotations for \texttt{actionBuilders} and \texttt{index}, the analyzer computes \texttt{additionalCount = 1}, allowing it to set $\tau = 1$ and achieve precise convergence with \texttt{i = [0,1]}.

\texttt{revokeStableMaster} (Core) exhibits similar behavior.
It iterates \texttt{for (uint256 i = 0; i < stablecoinListLength - 1; i++)} with simple index-based operations.
The annotation \texttt{// @StateVar \_stablecoinList = arrayAddress[2,3,4];} yields \texttt{stablecoinListLength = 3}, so the loop bound becomes \texttt{3 - 1 = 2}, setting $\tau = 2$ and achieving precise convergence with \texttt{i = [0,2]}.

\smallskip
\noindent\textbf{Pattern 3: Uninitialized Local Variables (Developer-Fixable).}
When local variables lack explicit initialization, precision loss can occur.
\texttt{getTotalDeposit} (TimeLockPool) declares \texttt{uint256 total;} without initialization
and then accumulates values in a loop.
For example, when appropriate annotations are provided for the \texttt{depositsOf} array elements, the analyzer infers a loop bound of 3 (setting $\tau = 3$) and correctly computes \texttt{i = [0,3]} after the loop.
However, \textsc{SolQDebug} conservatively models uninitialized variables as $\top$ (unknown), causing \texttt{total} to remain $\top = [0, 2^{256}-1]$ regardless of the precise loop bound.

This pattern represents a developer-fixable limitation.
Explicitly initializing \texttt{total = 0} would enable precise tracking (yielding \texttt{total = [700,1000]} for the annotated example).
Annotations cannot compensate for missing initialization because the interval domain soundly treats uninitialized reads as arbitrary values.

\smallskip
\noindent\textbf{Pattern 4: Data-Dependent Accumulation.}
Even when loop bounds are precisely known,
variables that accumulate based on data-dependent conditions may diverge under widening.
\texttt{\_removeFromTokens} (AvatarArtMarketplace) illustrates this limitation.
The loop iterates \texttt{for (uint tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++)}
where \texttt{tokenCount} is known from annotations.
With appropriate annotations for \texttt{\_tokens} and \texttt{tokenId}, the analyzer infers \texttt{tokenCount = 3} (setting $\tau = 3$) and correctly computes \texttt{tokenIndex = [0,3]} after the loop.
However, \texttt{resultIndex} inside the loop increments conditionally (\texttt{if (tokenItemId != tokenId) resultIndex++}) based on array element comparisons, depending on data values rather than the loop index itself.

Once the widening threshold is exceeded, \textsc{SolQDebug} widens \texttt{resultIndex} to $[0, \infty]$.
The interval domain cannot track correlations between array contents and conditional accumulation.
This pattern represents an inherent limitation of the interval domain.
Annotations of iteration bounds cannot prevent widening when variable updates depend on unpredictable data rather than iteration count.

\medskip
\noindent\fbox{%
\begin{minipage}{0.96\linewidth}
\textbf{Answer to RQ3:}
\textsc{SolQDebug} improves loop analysis precision for constant-bounded and annotation-enabled dynamic loops.
Remaining precision loss arises from developer-fixable initialization issues and inherent interval domain limitations in tracking data-dependent accumulation.
\end{minipage}%
}

\section{Discussion}

\subsection{Why use Abstract Interpretation with Interval Domain for Debugging}

In this work, debugging refers to a developer-led, interactive exploration activity that
occurs during code editing, before deployment. Developers specify debug annotations
and immediately observe program behaviors at the source level. This edit-time feedback
loop imposes strict requirements on the analysis technique.

\smallskip
\noindent\textbf{Why Abstract Interpretation?}
Compared to other static analysis, dynamic analysis, and machine learning techniques,
AI provides two properties essential for interactive debugging:
\begin{itemize}
  \item \textbf{Termination.} AI enforces convergence through widening at loops and joins at control-flow merges, guaranteeing bounded analysis time regardless of program complexity.

  \item \textbf{Explainability.} AI produces explicit abstract values that developers can inspect and interpret at the statement level.
\end{itemize}

\smallskip
\noindent\textbf{Why Interval Domain?}
Among abstract domains, intervals were chosen for responsiveness. Intervals require only
basic arithmetic on bounds, enabling millisecond-scale updates. In contrast, relational
domains (e.g., zones, polyhedra) track variable correlations through expensive constraint
solving that would break the interactive feedback loop.

\smallskip
\noindent\textbf{Precision-Responsiveness Tradeoff.}
AI with interval domain prioritizes responsiveness over precision, a tradeoff justified
by the interactive debugging context. Edit-time debugging fundamentally requires sub-second
feedback to maintain developer flow. Developers iterate rapidly through code edits,
and analysis delays that exceed even a few seconds would break this interactive loop,
forcing developers back to the traditional compile-deploy-debug cycle.
\textsc{SolQDebug} achieved 350$\times$ median speedup over Remix IDE (RQ1),
delivering millisecond-scale feedback that keeps developers in flow.
Although AI's precision is inherently conservative, this limitation was mitigated
by providing developers with annotation-based techniques to control precision where needed.
The evaluation shows that such techniques can reduce imprecision in practice for common
smart contract patterns (cf.\ RQ2, RQ3).
\vspace{0.25em}

    \subsection{Current Limitations}
    The current scope and analysis introduce several limitations. First, the focus is on
    single-contract, single-transaction functions. Inter-contract calls, multi-transaction workflows,
    proxies, and inheritance hierarchies are currently out of scope. As a result,
    a developer study in larger project settings has not yet been conducted. Consequently, the usability and
    interpretability of edit-time feedback across multi-contract workflows remain unvalidated.

    Second, the interval domain exhibits inherent precision limitations due to over-approximation.
    Arithmetic operations such as multiplication and division expand interval ranges combinatorially,
    control-flow joins compute least upper bounds that may encompass infeasible values, and
    loops apply widening to guarantee termination, sacrificing precision particularly for
    data-dependent accumulation patterns. As demonstrated in RQ2 and RQ3, such operations
    result in widened ranges that may include infeasible values. While this trade-off preserves
    edit-time responsiveness, it limits precision for complex data-dependent computations.

\section{Related Works}

    \subsection{Solidity IDEs and Debuggers}
        Modern Solidity development environments either embed a debugger or integrate external
        debugging plug-ins. Remix IDE~\citep{remix} is the most widely used web IDE. It supports syntax
        highlighting, one-click compilation, and a bytecode-level debugger that lets users step
        through EVM instructions and inspect stack, memory, and storage. Hardhat~\citep{hardhat}
        is a Node.js-based framework that couples the Solidity compiler with an Ethereum runtime. It integrates with Visual Studio Code extensions to provide step-by-step debugging of transaction execution. Foundry Forge~\citep{forge} is a command-line toolchain oriented toward fast,
        reproducible unit testing. The command \texttt{forge test} spins up an ephemeral fork,
        deploys contracts, executes annotated test functions, and enables replay through Forge Debug.
        Solidity Debugger Pro~\citep{soldepro} is a Visual Studio Code extension that performs runtime debugging over
        concrete transactions and integrates with Hardhat.

        In summary, these debuggers operate on compiled artifacts or post-deployment traces.
        By contrast, \textsc{SolQDebug} targets pre-deployment authoring, accepts partial fragments
        and symbolic annotations, and reports line-level effects via AI during
        editing.

    \subsection{Solidity Vulnerability Detection and Verification}
        Security analysis of smart contracts can be categorized into four main families of
        techniques.
        First, static analysis tools reason over source or bytecode without running the contract.
        Representative systems include rule-based analyzers such as Securify and Slither
        \citep{securify,slither}, symbolic-execution tools like Mythril \citep{mythril},
        knowledge-graph approaches such as Solidet \citep{solidet}, and CFG refinement
        techniques as in Ethersolve \citep{ethersolve}.
        Second, dynamic testing and fuzzing exercise deployed or locally simulated contracts to uncover
        faults and security issues.
        ContractFuzzer mutates Application Binary Interface (ABI)-level inputs \citep{confuzz}, Echidna brings property-based
        fuzzing into developer workflows \citep{echidna}, sFuzz adapts scheduling for higher
        coverage \citep{sfuzz}, TransRacer finds transaction-ordering races \citep{transracer}, and
        Ityfuzz leverages snapshotting to decouple executions from chain nondeterminism
        \citep{ityfuzz}.
        Third, formal verification aims to prove safety properties or refute counterexamples at compile
        time. Examples include ZEUS, VeriSmart, and SmartPulse \citep{zeus,verismart,pulse}.
        Finally, learning-based approaches train models to predict vulnerabilities or triage candidates, e.
        g., via data-flow--aware pretraining, IoT-oriented classifiers, or prompt-tuning for detector
        adaptation \citep{peculiar,tmlvd,pscvfinder}.

        These approaches have substantially advanced vulnerability detection and property checking
        for smart contracts. However, they target complete programs and focus on vulnerability detection rather than providing edit-time feedback. In contrast, \textsc{SolQDebug}
        provides real-time analysis as developers write code, enabling immediate understanding of program behavior without requiring complete contracts.
    
    \subsection{Solidity-Specific Abstract Interpretation Frameworks}
        AI is a well-established framework for static analysis and has been
        adapted to many programming languages. Two recent studies apply it to Solidity~\citep{flow,
        DBM}. The first uses the Pos domain to construct a theoretical model for taint
        (information-flow) analysis~\citep{flow}, while the second uses the Difference-Bound
        Matrix (DBM) domain to generate state invariants and detect re-entrancy vulnerabilities,
        including the DAO attack~\citep{DBM, dao}. However, both approaches operate on fully written
        contracts and provide no support for line-by-line interpretation or developer interaction
        within an IDE.

        \textsc{SolQDebug} builds upon these AI frameworks but targets interactive debugging
        rather than invariant generation or information flow analysis. Unlike these approaches that analyze complete contracts, \textsc{SolQDebug} incrementally updates
        the control-flow graph and abstract state during editing, allowing developers to use debug annotations
        to guide interval analysis and receive edit-time feedback without requiring complete contracts.
    
    \subsection{Interactive Abstract Interpretation for Traditional Languages}
        Beyond Solidity, the broader programming languages community has increasingly focused
        on making abstract interpretation interactive. Recent work integrates static analysis
        directly into IDEs for C, Java, and other traditional languages, delivering live feedback
        during editing \citep{daig, ds, iac, iaj, fap}. While these systems share \textsc{SolQDebug}'s
        goal of edit-time responsiveness, they differ in language semantics, domain requirements,
        and input mechanisms.
        \citet{daig} proposed demanded abstract interpretation, which incrementally rebuilds only
        the analysis nodes touched by an edit.
        A follow-up \citet{ds} generalized this to procedure summaries, enabling inter-procedural
        reuse.
        \citet{iac} extended Goblint with incremental support for multithreaded C, selectively
        recomputing only genuinely affected facts and maintaining IDE-level responsiveness.
        \citet{iaj} introduced IntraJ, a Language Server Protocol (LSP)-integrated analyzer for Java 11 that computes only the
        Abstract Syntax Tree (AST) and data-flow facts needed for the current view, keeping feedback under 100 ms.
        \citet{fap} achieved fast yet precise interval analysis on call graphs via one top-down and
        multiple bottom-up passes, and later introduced an incremental variant that revisits only
        the impacted functions.

        While these frameworks demonstrate the feasibility of interactive abstract interpretation
        in traditional languages, \textsc{SolQDebug} represents the first application of this paradigm
        to Solidity. Beyond language adaptation, it introduces an annotation-guided approach where developers
        specify debug annotations directly in source code to explore multiple execution scenarios in a single analysis pass. This enables Solidity developers to benefit from interactive static analysis without deploying contracts to a blockchain.

\section{Conclusion}
    This paper presented SolQDebug, the first interactive source-level debugger for Solidity
    that eliminates the traditional compile-deploy-debug cycle. Through interactive parsing,
    line-to-node indexing for incremental CFG construction, and annotation-guided abstract interpretation, SolQDebug
    provides millisecond-scale feedback directly within the editor.

    Evaluation on 30 real-world DAppSCAN functions demonstrated a 350$\times$ median speedup
    over Remix IDE (0.15s vs. 53.0s). Our analysis showed that annotation-guided interpretation
    enables precise analysis across diverse execution paths while maintaining soundness guarantees.
    These results demonstrated that SolQDebug effectively bridges the interactivity gap in
    Solidity debugging, bringing the development experience closer to modern IDEs and
    enhancing software quality in the blockchain ecosystem.

    Future work includes extending support to inter-contract and multi-transaction contexts,
    conducting user studies to assess practical adoption, and applying EVM Object Format (EOF)-based analysis
    to support inter-contract debugging when source code is unavailable.

\section*{Acknowledgements}
This work was supported by the Institute of Information \& communications Technology Planning \& Evaluation (IITP) grant funded by the Korean government (MSIT) (RS-2021-II210177, High Assurance of Smart Contract for Secure Software Development Life Cycle).

\section*{Author Contributions}
Inseong Jeon participated in conceptualization, methodology design, system implementation, data collection, experiments, and manuscript writing. Sundeuk Kim and Hyunwoo Kim assisted in experiments, data collection and analysis, and contributed to manuscript writing. Hoh Peter In provided resources, assisted in editing the manuscript, and supervised the entire project. All authors reviewed and approved the final version of the manuscript.

\section*{Data Availability}
The curated benchmark dataset of 30 Solidity contracts derived from DAppSCAN~\citep{dappscan}, along with the evaluation scripts and experimental results, are available at \url{https://github.com/iwwyou/SolDebug/tree/main}.

\section*{Declarations}

\noindent\textbf{Competing interests} The authors declare no competing interests.

\noindent\textbf{Ethical approval} Not applicable since there are no human and/or animal studies included in this paper.

\begin{thebibliography}{99}

\bibitem[ANTLR(2025)]{antlr}
ANTLR: \url{https://www.antlr.org/} (2025). Accessed November 2025

\bibitem[ChatGPT(2025)]{gpt}
ChatGPT: \url{https://chatgpt.com/} (2025). Accessed November 2025

\bibitem[CoinMarketCap(2025)]{coinmarketcap}
CoinMarketCap: \url{https://coinmarketcap.com/} (2025). Accessed November 2025

\bibitem[Chen et~al.(2025)]{smart contract evolution}
Chen, X., et al.: Characterizing smart contract evolution. ACM Transactions on Software Engineering and Methodology (2025). https://doi.org/10.1145/3719004

\bibitem[Chimdyalwar(2024)]{fap}
Chimdyalwar, B.: Fast and precise interval analysis on industry code. In: 2024 IEEE 35th
International Symposium on Software Reliability Engineering Workshops (ISSREW) (2024). https://doi.org/10.1109/ISSREW63542.2024.00049

\bibitem[ConsenSys Diligence(2025)]{psp}
ConsenSys Diligence: Python Solidity Parser. \url{https://github.
com/ConsenSysDiligence/python-solidity-parser} (2025). Accessed November 2025

\bibitem[Cousot and Cousot(1977)]{cousot}
Cousot, P., Cousot, R.: Abstract interpretation: a unified lattice model for static analysis of
programs by construction or approximation of fixpoints. In: Proceedings of the 4th ACM
SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL) (1977). https://doi.org/10.1145/512950.512973

\bibitem[Erhard et~al.(2024)]{iac}
Erhard, J., et al.: Interactive abstract interpretation: reanalyzing multithreaded C programs for
cheap. International Journal on Software Tools for Technology Transfer (2024). https://doi.org/10.1007/s10009-024-00768-9

\bibitem[Foundry Forge(2025)]{forge}
Foundry Forge: \url{https://book.getfoundry.sh/reference/forge/forge/} (2025). Accessed November
2025

\bibitem[Grieco et~al.(2020)]{echidna}
Grieco, G., et al.: Echidna: effective, usable, and fast fuzzing for smart contracts. In:
Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA),
pp. 557--560 (2020). https://doi.org/10.1145/3395363.3404366

\bibitem[Halder et~al.(2023)]{flow}
Halder, R., et al.: Analyzing information flow in Solidity smart contracts. In: Distributed
Computing to Blockchain, pp. 105--123. Academic Press (2023)

\bibitem[Halder(2024)]{DBM}
Halder, R.: State-based invariant property generation of Solidity smart contracts using abstract
interpretation. In: 2024 IEEE International Conference on Blockchain (2024). https://doi.org/10.1109/Blockchain62396.2024.00038

\bibitem[Hardhat(2025)]{hardhat}
Hardhat: \url{https://hardhat.org/} (2025). Accessed November 2025

\bibitem[Hu et~al.(2023)]{solidet}
Hu, T., et al.: Detect defects of Solidity smart contract based on the knowledge graph. IEEE
Transactions on Reliability 73(1), 186--202 (2023). https://doi.org/10.1109/TR.2023.3233999

\bibitem[JetBrains(2025)]{pycharm}
JetBrains: PyCharm. \url{https://www.jetbrains.com/pycharm/} (2025). Accessed November 2025

\bibitem[Jiang et~al.(2018)]{confuzz}
Jiang, B., Liu, Y., Chan, W.K.: ContractFuzzer: fuzzing smart contracts for vulnerability detection.
In: Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering (ASE)
, pp. 259--269 (2018). https://doi.org/10.1145/3238147.3238177

\bibitem[Kalra et~al.(2018)]{zeus}
Kalra, S., Goel, S., Dhawan, M., Sharma, S.: ZEUS: analyzing safety of smart contracts. In:
Proceedings of the 2018 Network and Distributed System Security Symposium (NDSS) (2018). https://doi.org/10.14722/ndss.2018.23082

\bibitem[Llama(2025)]{llama}
Llama: \url{https://www.llama.com/} (2025). Accessed November 2025

\bibitem[Ma et~al.(2023)]{transracer}
Ma, C., Song, W., Huang, J.: TransRacer: function dependence-guided transaction race detection for
smart contracts. In: Proceedings of the 31st ACM Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering (ESEC/FSE), pp. 947--959 (2023). https://doi.org/10.1145/3611643.3616281

\bibitem[Mehar et~al.(2019)]{dao}
Mehar, M.I., et al.: Understanding a revolutionary and flawed grand experiment in blockchain: the
DAO attack. Journal of Cases on Information Technology (2019). https://doi.org/10.4018/JCIT.2019010102

\bibitem[Microsoft(2025)]{visual}
Microsoft Visual Studio: \url{https://visualstudio.microsoft.com/ko/} (2025). Accessed November
2025

\bibitem[Nguyen et~al.(2020)]{sfuzz}
Nguyen, T.D., et al.: sFuzz: an efficient adaptive fuzzer for Solidity smart contracts. In:
Proceedings of the 42nd ACM/IEEE International Conference on Software Engineering (ICSE), pp.
778--788 (2020). https://doi.org/10.1145/3377811.3380334

\bibitem[Pasqua et~al.(2023)]{ethersolve}
Pasqua, M., et al.: Enhancing Ethereum smart-contracts static analysis by computing a precise
control-flow graph of Ethereum bytecode. Journal of Systems and Software 200, 111653 (2023). https://doi.org/10.1016/j.jss.2023.111653

\bibitem[Remix IDE(2025)]{remix}
Remix IDE: \url{https://remix.ethereum.org/} (2025). Accessed November 2025

\bibitem[Remix Benchmark(2025)]{remix_bench}
Remix Benchmark: \url{https://github.com/iwwyou/SolDebug/tree/main/Evaluation/RQ1_Latency} (2025). Accessed November 2025

\bibitem[Riouak et~al.(2024)]{iaj}
Riouak, I., et al.: IntraJ: an on-demand framework for intraprocedural Java code analysis.
International Journal on Software Tools for Technology Transfer (2024). https://doi.org/10.1007/s10009-024-00771-0

\bibitem[Rival and Yi(2020)]{yi}
Rival, X., Yi, K.: Introduction to Static Analysis: an Abstract Interpretation Perspective (2020)

\bibitem[Selenium with Python(2025)]{selenium}
Selenium with Python: \url{https://selenium-python.readthedocs.io/} (2025). Accessed November 2025

\bibitem[Shou et~al.(2023)]{ityfuzz}
Shou, C., Tan, S., Sen, K.: Ityfuzz: snapshot-based fuzzer for smart contract. In: Proceedings of
the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA), pp. 322--333
(2023). https://doi.org/10.1145/3597926.3598059

\bibitem[So et~al.(2020)]{verismart}
So, S., et al.: Verismart: a highly precise safety verifier for Ethereum smart contracts. In: 2020
IEEE Symposium on Security and Privacy (SP), pp. 1678--1694 (2020). https://doi.org/10.1109/SP40000.2020.00032

\bibitem[solcx(2025)]{solcx}
Solidity Compiler in Python (solcx): \url{https://solcx.readthedocs.io/en/latest/} (2025). Accessed
November 2025

\bibitem[Solidity(2025)]{solidity}
Solidity documentation: \url{https://docs.soliditylang.org/en/v0.8.30/} (2025). Accessed November
2025

\bibitem[Solidity Debugger Pro(2025)]{soldepro}
Solidity Debugger Pro: \url{https://www.soliditydbg.org/} (2025). Accessed November 2025

\bibitem[Solidity Language Grammar(2025)]{solgram}
Solidity Language Grammar: \url{https://docs.soliditylang.org/en/v0.8.30/grammar.html} (2025). Accessed November 2025

\bibitem[SolQDebug Implementation(2025)]{solqimpl}
SolQDebug Complete Implementation: \url{https://github.com/iwwyou/SolDebug/tree/main} (2025). Accessed November 2025

\bibitem[SolQDebug Language Grammar Rule(2025)]{solqrule}
Solidity Language Grammar Rule of SolQDebug : \url{https://github.
com/iwwyou/SolDebug/blob/main/Parser/Solidity.g4} . Accessed November 2025

\bibitem[Stein et~al.(2021)]{daig}
Stein, B., Chang, B.-Y.E., Sridharan, M.: Demanded abstract interpretation. In: Proceedings of the
42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI)
(2021). https://doi.org/10.1145/3453483.3454044

\bibitem[Stein et~al.(2024)]{ds}
Stein, B., Chang, B.-Y.E., Sridharan, M.: Interactive abstract interpretation with demanded
summarization. ACM Transactions on Programming Languages and Systems (2024). https://doi.org/10.1145/3648484

\bibitem[Stephens et~al.(2021)]{pulse}
Stephens, J., et al.: SmartPulse: automated checking of temporal properties in smart contracts. In:
2021 IEEE Symposium on Security and Privacy (SP), pp. 555--571 (2021). https://doi.org/10.1109/SP40001.2021.00085

\bibitem[Tsankov et~al.(2018)]{securify}
Tsankov, P., et al.: Securify: practical security analysis of smart contracts. In: Proceedings of
the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS), pp. 67--82 (2018). https://doi.org/10.1145/3243734.3243780

\bibitem[Feist et~al.(2019)]{slither}
Feist, J., Grieco, G., Groce, A.: Slither: a static analysis framework for smart contracts. In: 2019 IEEE/ACM 2nd
International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB), pp. 8--15
(2019). https://doi.org/10.1109/WETSEB.2019.00008

\bibitem[Wu et~al.(2021)]{peculiar}
Wu, H., et al.: Peculiar: smart contract vulnerability detection based on crucial data-flow graph
and pre-training techniques. In: 2021 IEEE 32nd International Symposium on Software Reliability
Engineering (ISSRE), pp. 378--389 (2021). https://doi.org/10.1109/ISSRE52982.2021.00047

\bibitem[Yao et~al.(2022)]{mythril}
Yao, Y., et al.: An improved vulnerability detection system of smart contracts based on symbolic
execution. In: 2022 IEEE International Conference on Big Data (Big Data), pp. 3225--3234 (2022). https://doi.org/10.1109/BigData55660.2022.10020730

\bibitem[Yu et~al.(2023)]{pscvfinder}
Yu, L., et al.: PSCVFinder: a prompt-tuning based framework for smart contract vulnerability
detection. In: 2023 IEEE 34th International Symposium on Software Reliability Engineering (ISSRE),
pp. 556--567 (2023). https://doi.org/10.1109/ISSRE59848.2023.00030

\bibitem[Zheng et~al.(2024)]{dappscan}
Zheng, Z., et al.: Dappscan: building large-scale datasets for smart contract weaknesses in dApp
projects. IEEE Transactions on Software Engineering (2024). https://doi.org/10.1109/TSE.2024.3383422

\bibitem[Zhou et~al.(2022)]{tmlvd}
Zhou, Q., et al.: Vulnerability analysis of smart contract for blockchain-based IoT applications: a
machine learning approach. IEEE Internet of Things Journal 9(24), 24695--24707 (2022). https://doi.org/10.1109/JIOT.2022.3196269

\bibitem[Zou et~al.(2019)]{interview}
Zou, W., et al.: Smart contract development: challenges and opportunities. IEEE Transactions on
Software Engineering (2019). https://doi.org/10.1109/TSE.2019.2942301

\end{thebibliography}

\FloatBarrier
\newpage
\appendix

\section{Interactive Parser Grammar Specification}
\label{appendix:interactive-grammar}

This appendix provides the complete grammar specification for \textsc{SolQDebug}'s interactive parser.

\subsection{Entry Rules for Solidity Program Fragments}

\subsubsection{Rule 1: \texttt{interactiveSourceUnit}}
\noindent\textbf{Purpose.} Accepts top-level declarations: functions, contracts, interfaces, libraries, state variables, pragmas, and imports.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveSourceUnit
  : (interactiveStateVariableElement | interactiveFunctionElement
    | interfaceDefinition | libraryDefinition | contractDefinition
    | pragmaDirective | importDirective)* EOF ;
\end{verbatim}

\subsubsection{Rule 2: \texttt{interactiveEnumUnit}}
\noindent\textbf{Purpose.} Accepts enum member items added after the enum shell.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveEnumUnit : (interactiveEnumItems)* EOF;
interactiveEnumItems : identifier (',' identifier)*;
\end{verbatim}

\subsubsection{Rule 3: \texttt{interactiveStructUnit}}
\noindent\textbf{Purpose.} Accepts struct member declarations added after the struct shell.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveStructUnit : (structMember)* EOF;
structMember : typeName identifier ';' ;
\end{verbatim}

\subsubsection{Rule 4: \texttt{interactiveBlockUnit}}
\noindent\textbf{Purpose.} Accepts statements and control-flow skeletons inside function bodies.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveBlockUnit
  : (interactiveBlockItem)* EOF;

interactiveBlockItem
  : interactiveStatement | uncheckedBlock;

interactiveStatement
  : interactiveSimpleStatement
  | interactiveIfStatement
  | interactiveForStatement
  | interactiveWhileStatement
  | interactiveDoWhileDoStatement
  | interactiveTryStatement
  | returnStatement
  | emitStatement
  | revertStatement
  | requireStatement
  | assertStatement
  | continueStatement
  | breakStatement
  | assemblyStatement;

interactiveIfStatement
  : 'if' '(' expression ')' '{' '}' ;

interactiveForStatement
  : 'for' '(' (simpleStatement | ';') expression? ';' expression? ')' '{' '}' ;

interactiveWhileStatement
  : 'while' '(' expression ')' '{' '}' ;

interactiveDoWhileDoStatement
  : 'do' '{' '}' ;

interactiveTryStatement
  : 'try' expression ('returns' '(' parameterList ')')? '{' '}' ;
\end{verbatim}

\noindent The \texttt{interactiveStatement} production includes skeleton rules for
control structures with empty bodies (e.g., \texttt{interactiveIfStatement}, \texttt{interactiveForStatement}),
enabling incremental construction of control flow. As developers type statements inside these
empty bodies, \texttt{interactiveBlockUnit} is recursively invoked to parse each new line.

\subsubsection{Rule 5: \texttt{interactiveDoWhileUnit}}
\noindent\textbf{Purpose.} Accepts the \texttt{while} tail of a \texttt{do\{...\}} loop.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveDoWhileUnit : (interactiveDoWhileWhileStatement)* EOF;
interactiveDoWhileWhileStatement : 'while' '(' expression ')' ';' ;
\end{verbatim}

\subsubsection{Rule 6: \texttt{interactiveIfElseUnit}}
\noindent\textbf{Purpose.} Accepts \texttt{else} or \texttt{else if} branches.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveIfElseUnit : (interactiveElseStatement)* EOF;
interactiveElseStatement : 'else' (interactiveIfStatement | '{' '}') ;
\end{verbatim}

\subsubsection{Rule 7: \texttt{interactiveCatchClauseUnit}}
\noindent\textbf{Purpose.} Accepts \texttt{catch} clauses following a \texttt{try}.

\noindent\textbf{Grammar:}
\begin{verbatim}
interactiveCatchClauseUnit : (interactiveCatchClause)* EOF;
interactiveCatchClause : 'catch' (identifier? '(' parameterList ')')? '{' '}' ;
\end{verbatim}

\subsection{Entry Rule for Debugging Annotations}

\subsubsection{\texttt{debugUnit}}
\noindent\textbf{Purpose.} Parses batch-annotation lines that specify initial abstract values for variables.

\noindent\textbf{Annotation types:}
\begin{itemize}
  \item \texttt{@GlobalVar}: Assigns values to global variables (e.g., \texttt{msg.sender}, \texttt{block.timestamp})
  \item \texttt{@StateVar}: Assigns values to contract state variables
  \item \texttt{@LocalVar}: Assigns values to function parameters and local variables
\end{itemize}

\noindent\textbf{Grammar:}
\begin{verbatim}
debugUnit : (debugGlobalVar | debugStateVar | debugLocalVar)* EOF;
debugGlobalVar : '//' '@GlobalVar' identifier ('.' identifier)? '=' globalValue ';' ;
debugStateVar : '//' '@StateVar' lvalue '=' value ';' ;
debugLocalVar : '//' '@LocalVar' lvalue '=' value ';' ;
\end{verbatim}

\noindent\textbf{Supported L-value patterns:} Simple variables, array/mapping access (\texttt{arr[i]}, \texttt{map[key]}), struct fields (\texttt{s.field}), and nested combinations.

\noindent\textbf{Value specification:} Integer intervals \texttt{[l,u]}, symbolic addresses \texttt{symbolicAddress n}, boolean values, and symbolic placeholders.

\section{Incremental CFG Construction Patterns}
\label{appendix:cfg-patterns}

This appendix provides the complete CFG construction patterns for \textsc{SolQDebug}'s incremental CFG builder.
The patterns show how each statement type is incrementally spliced into the existing control-flow graph.

\subsection{CFG Hierarchy}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\footnotesize},
  cfgblock/.style={rounded rectangle, draw, thick, minimum width=2.8cm, minimum height=0.85cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (entry) {Entry};
  \node[block, below=of entry] (state) {State Variable Node};
  \node[cfgblock, below=of state] (constructor) {ConstructorCFG};
  \node[cfgblock, below left=1.5cm and 2.5cm of constructor] (func1) {FunctionCFG};
  \node[cfgblock, below=1.5cm of constructor] (func2) {FunctionCFG};
  \node[dots, right=0.5cm of func2] (funcdots) {...};
  \node[cfgblock, below right=1.5cm and 2.5cm of constructor] (funcn) {FunctionCFG};
  \node[block, below=1.5cm of func2] (exit) {Exit};

  \draw[->, thick] (entry) -- (state);
  \draw[->, thick] (state) -- (constructor);
  \draw[->, thick] (constructor) -| (func1);
  \draw[->, thick] (constructor) -- (func2);
  \draw[->, thick] (constructor) -| (funcn);
  \draw[->, thick] (func1) |- (exit);
  \draw[->, thick] (func2) -- (exit);
  \draw[->, thick] (funcn) |- (exit);
\end{tikzpicture}
\caption{Structure of ContractCFG. The contract-level CFG sequences state variable initialization, constructor execution, and all function definitions.}
\label{fig:contract-cfg}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 3cm,
  block/.style={rectangle, draw, thick, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\footnotesize},
  cfgblock/.style={rounded rectangle, draw, thick, minimum width=2.8cm, minimum height=0.85cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  % Main sequence
  \node[block] (entry) {Entry};
  \node[block, below=of entry] (basic) {Basic Node};
  \node[dots, below left=1.5cm and 0.5cm of basic] (dots1) {...};
  \node[dots, below=1.5cm of basic] (dots2) {...};
  \node[dots, below right=1.5cm and 0.5cm of basic] (dots3) {...};
  \node[block, below=3cm of basic] (exit) {Exit};

  % ModifierCFG on the right
  \node[cfgblock, right=of basic] (modifier) {ModifierCFG};

  % Solid edges
  \draw[->, thick] (entry) -- (basic);
  \draw[->, thick] (basic) -- (dots1);
  \draw[->, thick] (basic) -- (dots2);
  \draw[->, thick] (basic) -- (dots3);
  \draw[->, thick] (dots1) |- (exit);
  \draw[->, thick] (dots2) -- (exit);
  \draw[->, thick] (dots3) |- (exit);

  % Bidirectional dashed edges to ModifierCFG
  \draw[<->, thick, dashed] (entry.north) -- ++(0,0.5) -| (modifier.north);
  \draw[<->, thick, dashed] (exit.south) -- ++(0,-0.5) -| (modifier.south);
\end{tikzpicture}
\caption{Structure of FunctionCFG. Each function maintains its own control-flow graph. When modifiers are present, control flows from the function entry to the modifier, and returns from the modifier's placeholder (\texttt{\_}) back to the function body, eventually reaching the function exit.}
\label{fig:function-cfg}
\end{figure}

\subsection{Statement-Level Construction Patterns}

The following patterns show how each statement type is incrementally spliced into the existing control-flow graph.
All patterns assume an initial state with a current node connected to successors (\texttt{...}),
as illustrated in the simple statement example.

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm,
  block/.style={rectangle, draw, thick, minimum width=2.5cm, minimum height=0.8cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[block, below=of current, fill=green!15] (new) {New Statement\\Node};
  \node[dots, below=of new] (succ) {...};

  \draw[->, thick] (current) -- node[right] {splice} (new);
  \draw[->, thick] (new) -- node[right] {reconnect} (succ);

  % Before state (left side)
  \node[block, left=3cm of current] (before_cur) {Current Node};
  \node[dots, below=of before_cur] (before_succ) {...};
  \draw[->, thick] (before_cur) -- (before_succ);

  \node[above=0.3cm of before_cur, font=\footnotesize\bfseries] {Before};
  \node[above=0.3cm of current, font=\footnotesize\bfseries] {After};
\end{tikzpicture}
\caption{Simple statement insertion: single node spliced between current node and successors}
\label{fig:new-simple-statement}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 1.5cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=of current, fill=green!15] (cond) {guard};
  \node[block, below left=of cond, fill=green!15] (true) {True\\Node};
  \node[block, below right=of cond, fill=green!15] (false) {False\\Node};
  \node[block, below=2.5cm of cond, fill=green!15] (join) {If Join\\Node};
  \node[dots, below=of join] (succ) {...};

  \draw[->, thick] (current) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (false);
  \draw[->, thick] (true) |- (join);
  \draw[->, thick] (false) |- (join);
  \draw[->, thick] (join) -- (succ);
\end{tikzpicture}
\caption{If statement insertion. The builder creates a \textsc{condition node}, two nodes for true/false arms, and an \textsc{if join}}
\label{fig:new-if}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=1.8cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.3cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=1cm of current] (if_cond) {if guard};
  \node[block, below left=1.2cm and 2.2cm of if_cond] (if_true) {If True\\Node};
  \node[dots, below=0.6cm of if_true] (if_dots) {...};

  % else-if branch (highlighted)
  \node[cond, below right=1.2cm and 2.2cm of if_cond, fill=green!15] (elif_cond) {else-if\\guard};
  \node[block, below left=1cm and 1.5cm of elif_cond, fill=green!15] (elif_true) {Else-If True\\Node};
  \node[block, below right=1cm and 1.5cm of elif_cond, fill=green!15] (elif_false) {Else-If False\\Node};

  \node[block, below=2.5cm of elif_cond, fill=green!15] (elif_join) {Else-If Join\\Node};
  \node[block, below=5.5cm of if_cond] (if_join) {If Join\\Node};
  \node[dots, below=0.6cm of if_join] (succ) {...};

  \draw[->, thick] (current) -- (if_cond);
  \draw[->, thick] (if_cond) -| node[above left, pos=0.25] {T} (if_true);
  \draw[->, thick] (if_cond) -| node[above right, pos=0.25] {F} (elif_cond);
  \draw[->, thick] (elif_cond) -| node[above left, pos=0.25] {T} (elif_true);
  \draw[->, thick] (elif_cond) -| node[above right, pos=0.25] {F} (elif_false);
  \draw[->, thick] (if_dots) -- ++(0,-1.5) -| (if_join);
  \draw[->, thick] (elif_true) |- (elif_join);
  \draw[->, thick] (elif_false) |- (elif_join);
  \draw[->, thick] (elif_join) |- (if_join);
  \draw[->, thick] (if_join) -- (succ);
\end{tikzpicture}
\caption{Else-if statement insertion. The builder replaces the false arm with a new \textsc{condition node}, two nodes, and an \textsc{else-if join}}
\label{fig:new-else-if}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1.2cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=1cm of current] (cond) {guard};
  \node[block, below left=1.2cm and 2cm of cond] (true) {True\\Node};
  \node[dots, below=0.6cm of true] (true_dots) {...};
  \node[block, below right=1.2cm and 2cm of cond, fill=green!15] (else) {Else\\Node};
  \node[dots, below=0.6cm of else] (else_dots) {...};
  \node[block, below=3.5cm of cond] (join) {If Join\\Node};
  \node[dots, below=0.6cm of join] (succ) {...};

  \draw[->, thick] (current) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (else);
  \draw[->, thick] (true) -- (true_dots);
  \draw[->, thick] (else) -- (else_dots);
  \draw[->, thick] (true_dots) -- ++(0,-0.5) -| (join);
  \draw[->, thick] (else_dots) -- ++(0,-0.5) -| (join);
  \draw[->, thick] (join) -- (succ);
\end{tikzpicture}
\caption{Else statement insertion. The builder replaces the false branch node with a new else node, connecting to the \textsc{if join}}
\label{fig:new-else}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2.2cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  phi/.style={circle, draw, thick, fill=blue!15, minimum size=1cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[phi, below=1cm of current, fill=green!15] (phi) {$\phi$};
  \node[cond, below=1cm of phi, fill=green!15] (cond) {guard};
  \node[block, below left=1.2cm and 2.2cm of cond, fill=green!15] (body) {Body\\Entry Node};
  \node[block, below right=1.2cm and 2.2cm of cond, fill=green!15] (exit) {Loop\\Exit Node};
  \node[dots, below=0.6cm of exit] (succ) {...};

  \draw[->, thick] (current) -- (phi);
  \draw[->, thick] (phi) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (body);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (exit);
  \draw[->, thick] (body) -- ++(-1.5,0) |- node[above left, pos=0.15] {back edge} (phi);
  \draw[->, thick] (exit) -- (succ);
\end{tikzpicture}
\caption{While loop insertion. The builder creates a \textsc{fixpoint evaluation node} $\phi$, a \textsc{condition node}, a loop body node, and a \textsc{loop exit node}}
\label{fig:new-while}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2.5cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.3cm, align=center, font=\footnotesize},
  phi/.style={circle, draw, thick, fill=blue!15, minimum size=0.8cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[phi] (phi) {$\phi$};
  \node[cond, below=0.8cm of phi] (cond) {guard};
  \node[block, below left=1cm and 2cm of cond] (body) {Body Node};
  \node[dots, below=0.5cm of body] (body_dots) {...};
  \node[block, below=0.5cm of body_dots, fill=green!15] (break) {\texttt{break}};
  \node[block, below right=1cm and 2cm of cond] (exit) {Loop\\Exit Node};

  \draw[->, thick] (phi) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.2] {T} (body);
  \draw[->, thick] (cond) -| node[above right, pos=0.2] {F} (exit);
  \draw[->, thick] (body) -- (body_dots);
  \draw[->, thick] (body_dots) -- (break);
  \draw[->, thick] (break) -| node[above right, pos=0.6] {redirect} (exit);
\end{tikzpicture}
\caption{Break statement insertion. The \texttt{break} node's outgoing edge is redirected to the \textsc{loop exit node}}
\label{fig:new-break}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2.5cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.3cm, align=center, font=\footnotesize},
  phi/.style={circle, draw, thick, fill=blue!15, minimum size=0.8cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[phi] (phi) {$\phi$};
  \node[cond, below=0.8cm of phi] (cond) {guard};
  \node[block, below left=1cm and 2cm of cond] (body) {Body Node};
  \node[dots, below=0.5cm of body] (body_dots) {...};
  \node[block, below=0.5cm of body_dots, fill=green!15] (continue) {\texttt{continue}};
  \node[block, below right=1cm and 2cm of cond] (exit) {Loop\\Exit Node};

  \draw[->, thick] (phi) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.2] {T} (body);
  \draw[->, thick] (cond) -| node[above right, pos=0.2] {F} (exit);
  \draw[->, thick] (body) -- (body_dots);
  \draw[->, thick] (body_dots) -- (continue);
  \draw[->, thick] (continue) -- ++(-1.5,0) |- node[left, pos=0.25] {redirect} (phi);
\end{tikzpicture}
\caption{Continue statement insertion. The \texttt{continue} node's outgoing edge is redirected to the loop's \textsc{fixpoint evaluation node} $\phi$}
\label{fig:new-continue}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  exit/.style={rectangle, draw, thick, rounded corners, fill=red!15, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[block, below=of current, fill=green!15] (return) {\texttt{return}\\Node};
  \node[exit, below right=0.5cm and 2cm of return] (exit) {RETURN\\EXIT};
  \node[dots, below left=0.5cm and 0.5cm of return] (detached) {...};

  \draw[->, thick] (current) -- (return);
  \draw[->, thick, bend left=15] (return) to node[above right] {rewire} (exit);
  \draw[->, thick, dashed, gray] (return) -- node[left, gray] {detached} (detached);
\end{tikzpicture}
\caption{Return statement insertion. The \texttt{return} node is rewired to the function's unique \textsc{return exit}}
\label{fig:new-return}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, transform shape,
  node distance=1cm and 2cm,
  block/.style={rectangle, draw, thick, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  cond/.style={diamond, draw, thick, aspect=2, minimum width=1.5cm, align=center, font=\footnotesize},
  exit/.style={rectangle, draw, thick, rounded corners, fill=red!15, minimum width=2cm, minimum height=0.7cm, align=center, font=\footnotesize},
  dots/.style={circle, draw=none, minimum size=0.3cm}
]
  \node[block] (current) {Current Node};
  \node[cond, below=of current, fill=green!15] (cond) {predicate};
  \node[block, below left=of cond, fill=green!15] (true) {True\\Node};
  \node[exit, below right=of cond] (error) {ERROR\\EXIT};
  \node[dots, below=of true] (succ) {...};

  \draw[->, thick] (current) -- (cond);
  \draw[->, thick] (cond) -| node[above left, pos=0.3] {T} (true);
  \draw[->, thick] (cond) -| node[above right, pos=0.3] {F} (error);
  \draw[->, thick] (true) -- (succ);
\end{tikzpicture}
\caption{Require statement insertion. The builder creates a \textsc{condition node} with true edge to a node and false edge to the \textsc{error exit}}
\label{fig:new-require}
\end{figure}

\section{Abstract Domain and Formal Semantics}
\label{app:semantics}

This appendix presents the abstract domain definitions and formal semantics used by \textsc{SolQDebug}'s abstract interpreter. The framework is based on interval analysis for numeric types, set domains for addresses, and lazy materialization for composite data structures.

\subsection{Language Syntax}

This work considers a subset of Solidity focusing on core control structures, expressions, and state manipulation relevant to the analysis.

\noindent\textbf{Expressions:}
\begin{align*}
e \in \mathsf{Expr}\ ::=\ & n \mid x \mid \mathsf{true} \mid \mathsf{false} \mid \mathsf{address\_literal}\\
& \mid e_1 \oplus e_2 \mid e_1\ \odot\ e_2 \mid e_1\ ?\ e_2 : e_3\\
& \mid e.f \mid e_1[e_2] \mid f(\overline{e}) \mid \neg e \mid \mathsf{delete}\ e
\end{align*}
where $\oplus \in \{+,-,*,/,\%,**,\&\&,||,\&,|,\wedge,<<,>>\}$ and $\odot \in \{<,\le,>,\ge,==,\ne\}$.

\noindent\textbf{Statements:}
\begin{align*}
s \in \mathsf{Stmt}\ ::=\ & \mathsf{skip} \mid s_1; s_2 \mid \tau\ x; \mid \tau\ x = e;\\
& \mid lv := e \mid \mathsf{delete}\ lv\\
& \mid \mathsf{if}\ p\ \mathsf{then}\ s_t\ \mathsf{else}\ s_f\\
& \mid \mathsf{while}\ p\ \mathsf{do}\ s\\
& \mid \mathsf{for}\ init; p; incr\ \mathsf{do}\ s\\
& \mid \mathsf{do}\ s\ \mathsf{while}\ p\\
& \mid \mathsf{return}\ e \mid \mathsf{assert}(p) \mid \mathsf{require}(p)\\
& \mid \mathsf{revert}(\cdots) \mid \mathsf{try}\ e\ (\mathsf{returns}\ (x))\ s_t\ \mathsf{catch}\ s_c\\
& \mid f(\overline{e})
\end{align*}
where $\tau$ ranges over types (\texttt{uint}, \texttt{int}, \texttt{bool}, \texttt{address}, structs, arrays, mappings), $lv$ denotes l-values (variables, fields, array/mapping elements), and $p$ denotes boolean expressions.

\subsection{Abstract Domain}

\noindent\textbf{Atomic abstract values:}
\begin{itemize}
\item \textbf{Unsigned integers:} $\widehat{\mathbb{U}}_N = \{[\ell,u] \mid 0 \le \ell \le u \le 2^N{-}1\} \cup \{\bot,\top^{\mathbb{U}}_N\}$
\item \textbf{Signed integers:} $\widehat{\mathbb{Z}}_N = \{[\ell,u] \mid -2^{N-1} \le \ell \le u \le 2^{N-1}{-}1\} \cup \{\bot,\top^{\mathbb{Z}}_N\}$
\item \textbf{Booleans:} $\widehat{\mathbb{B}} = \{\bot,\widehat{\mathsf{false}},\widehat{\mathsf{true}},\top\}$
\item \textbf{Addresses:} $\widehat{\mathbb{A}} = \{\bot\} \cup \wp_{\text{fin}}(\mathsf{AddrID}) \cup \{\top\}$ where $\bot = \emptyset$ (finite set of symbolic address identifiers)
\item \textbf{Bytes:} $\widehat{\mathbb{BY}}_K = \{\bot,\top_K\}$ (symbolic/opaque)
\item \textbf{Enums:} $\widehat{\mathsf{Enum}}(E) = \{[\ell,u]\mid 0\le \ell \le u \le |E|-1\}\cup\{\bot,\top_E\}$
\end{itemize}

\noindent\textbf{Composite values:}
\begin{itemize}
\item \textbf{Structs:} $\widehat{\mathsf{Struct}}(C) = \prod_{f\in\mathsf{fields}(C)} \widehat{\mathsf{Val}}_f$ (pointwise order)
\item \textbf{Arrays:} $\widehat{\mathsf{Arr}}(\tau) = (\hat{\ell},\hat{d},M)$ where $\hat{\ell}\in \widehat{\mathbb{U}}_{256}$ is length, $\hat{d}$ is default element, $M:\mathbb{N}\rightharpoonup \widehat{\tau}$ stores observed indices
\item \textbf{Mappings:} $\widehat{\mathsf{Map}}(\kappa\Rightarrow\tau) = (\hat{d},M)$ with default $\hat{d}$ and finite map $M$ for observed keys
\end{itemize}

\medskip
\noindent
Standard interval domain operations (order, join, meet, widening, narrowing) apply to integer and enum domains.

\subsection{Concrete Semantics}

\begin{table}[t]
  \caption{Concrete semantics (denotational)}
  \label{tab:conc-denot}
  \centering
  \small
  \setlength{\tabcolsep}{6pt}
  \renewcommand{\arraystretch}{1.12}
  \begin{tabularx}{\columnwidth}{@{}l X@{}}
    \toprule
    \textbf{Statement} & \textbf{Meaning} \\
    \midrule
    \textsf{skip} &
    $\llbracket \textsf{skip}\rrbracket(\sigma)=\Norm(\sigma)$\\

    $s_1; s_2$ &
    $\llbracket s_1; s_2\rrbracket(\sigma)=\big(\llbracket s_1\rrbracket(\sigma)\big)\ \triangleright\ (\lambda \sigma'.\,\llbracket s_2\rrbracket(\sigma'))$\\

    $\tau\ x;$ &
    $\llbracket \tau\ x;\rrbracket(\sigma)=\Norm\!\big(\sigma[x\mapsto \mathrm{zero}_\tau]\big)$\\

    $\tau\ x=e;$ &
    $\llbracket \tau\ x=e;\rrbracket(\sigma)=\Norm\!\big(\sigma[x\mapsto \llbracket e\rrbracket_\sigma]\big)$\\

    $\mathit{lv}:=e$ &
    $\llbracket \mathit{lv}:=e\rrbracket(\sigma)=\Norm\!\big(\mathrm{write}(\sigma,\,\mathrm{loc}_\sigma(\mathit{lv}),\,\llbracket e\rrbracket_\sigma)\big)$\\

    \textsf{delete}\ $\mathit{lv}$ &
    $\llbracket \textsf{delete}\ \mathit{lv}\rrbracket(\sigma)=\Norm\!\big(\mathrm{write}(\sigma,\,\mathrm{loc}_\sigma(\mathit{lv}),\,\mathrm{zero}_{\tau(\mathit{lv})})\big)$\\

    \textsf{if}\ $p$ \textsf{then}\ $s_t$ \textsf{else}\ $s_f$ &
    $\llbracket \cdot\rrbracket(\sigma)=
      \begin{cases}
        \llbracket s_t\rrbracket(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \llbracket s_f\rrbracket(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$\\

    \textsf{while}\ $p$ \textsf{do}\ $s$ &
    $F(H)(\sigma)=
      \begin{cases}
        \big(\llbracket s\rrbracket(\sigma)\big)\ \triangleright\ H & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \Norm(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$;
    $\llbracket \textsf{while}\ p\ \textsf{do}\ s\rrbracket=\mathrm{lfp}(F)$\\

    \textsf{for}\ $init$; $p$; $incr$ \textsf{do}\ $s$ &
    $F(H)(\sigma)=
      \begin{cases}
        \big(\llbracket s\rrbracket(\sigma)\big)\ \triangleright\ (\lambda \sigma'.\,\llbracket incr\rrbracket(\sigma')\ \triangleright\ H) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \Norm(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$;
    $\llbracket \textsf{for}\ init; p; incr\ \textsf{do}\ s\rrbracket(\sigma)=\llbracket init\rrbracket(\sigma)\ \triangleright\ (\lambda \sigma'.\,\mathrm{lfp}(F)(\sigma'))$\\

    \textsf{do}\ $s$ \textsf{while}\ $p$ &
    $F(H)(\sigma)=\llbracket s\rrbracket(\sigma)\ \triangleright\ (\lambda \sigma'.\,
      \begin{cases}
        H(\sigma') & \text{if }\llbracket p\rrbracket_{\sigma'}=\mathsf{true},\\
        \Norm(\sigma') & \text{if }\llbracket p\rrbracket_{\sigma'}=\mathsf{false}
      \end{cases})$;
    $\llbracket \textsf{do}\ s\ \textsf{while}\ p\rrbracket=\mathrm{lfp}(F)$\\

    \textsf{return}\ $e$ &
    $\llbracket \textsf{return}\ e\rrbracket(\sigma)=\Ret(\llbracket e\rrbracket_\sigma,\,\sigma)$\\

    \textsf{assert}$(p)$,\ \textsf{require}$(p)$ &
    $\llbracket \cdot\rrbracket(\sigma)=
      \begin{cases}
        \Norm(\sigma) & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{true},\\
        \Abort & \text{if }\llbracket p\rrbracket_\sigma=\mathsf{false}
      \end{cases}$\\

    \textsf{revert}$(\cdots)$ &
    $\llbracket \textsf{revert}(\cdots)\rrbracket(\sigma)=\Abort$\\

    \textsf{try}\ $e$ (\textsf{returns}\ $(x)$)\ $s_t$ \textsf{catch}\ $s_c$ &
    $\llbracket \cdot\rrbracket(\sigma)=
      \begin{cases}
        \llbracket s_t\rrbracket(\sigma[x\mapsto v]) & \text{if call succeeds with }v,\\
        \llbracket s_c\rrbracket(\sigma) & \text{if call reverts}
      \end{cases}$\\

    \textsf{call}$(\overline{e})$ &
    Internal: parameter binding; external: unspecified\\
    \bottomrule
  \end{tabularx}
\end{table}

\noindent\textbf{Result types:} Semantics return $\Norm(\sigma)$ (normal termination), $\Ret(v,\sigma)$ (return statement), or $\Abort$ (revert).

\medskip
\begin{itemize}
\item \textbf{Variables:} $\mathsf{Var}$ = set of variable identifiers
\item \textbf{Values:} $\mathsf{Val}$ includes:
  \begin{itemize}
  \item Unsigned integers: $\mathbb{U}_N = \{0,1,\ldots,2^N{-}1\}$
  \item Signed integers: $\mathbb{Z}_N = \{-2^{N-1},\ldots,2^{N-1}{-}1\}$
  \item Booleans: $\mathbb{B} = \{\mathsf{true},\mathsf{false}\}$
  \item Addresses: $\mathbb{A} = \mathsf{AddrID}$ (symbolic identifiers)
  \item Composite values: structs, arrays, mappings with concrete elements
  \end{itemize}
\item \textbf{Stores:} $\sigma \in \Sigma = \mathsf{Var} \rightharpoonup \mathsf{Val}$
\end{itemize}

\medskip
\noindent
L-value resolution $\mathrm{loc}_\sigma(\mathit{lv})$ and write $\mathrm{write}(\sigma,\ell,v)$ update the store. Expressions are pure: $\llbracket e\rrbracket_\sigma\in\mathsf{Val}$.

\noindent\textbf{Array/mapping materialization:}
$\mathrm{loc}_\sigma(a[i])$ extends $a$ up to $i$ with defaults if needed; $\mathrm{loc}_\sigma(m[k])$ creates $m[k]$ lazily if absent.

\subsection{Collecting Semantics}

For abstraction, we lift concrete semantics to sets of states.

\noindent\textbf{Collecting function semantics:} Given a function $f$ with concrete semantics $\llbracket f \rrbracket : \Sigma \times \mathsf{Val} \to \mathit{Result}$, the collecting semantics over state sets is:
\[
\mathcal{S}[[f]](S) = \{\sigma' \mid \exists \sigma \in S,\, v_{\text{in}} \in \mathsf{Val}.\, \llbracket f \rrbracket(\sigma, v_{\text{in}}) = \Norm(\sigma') \vee \llbracket f \rrbracket(\sigma, v_{\text{in}}) = \Ret(v_{\text{out}}, \sigma')\}
\]

\noindent\textbf{Reachable states:} The set of all reachable states during contract execution forms the collecting semantics, serving as the basis for abstract interpretation.

\subsection{Abstract Semantics (Denotational)}

Our abstract semantics is based on the well-established Galois connection for interval domains between concrete and abstract semantics, ensuring soundness. The abstraction function $\alpha$ and concretization function $\gamma$ connect concrete and abstract domains, guaranteeing that abstract computations safely over-approximate concrete behaviors.

\smallskip
\noindent\textbf{Abstract semantic domains:}
\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt]
\item \textbf{Abstract values:} $\widehat{\mathsf{Val}}$ = union of atomic abstract values ($\widehat{\mathbb{U}}_N$, $\widehat{\mathbb{Z}}_N$, $\widehat{\mathbb{B}}$, $\widehat{\mathbb{A}}$, etc.) and composite abstract values ($\widehat{\mathsf{Struct}}$, $\widehat{\mathsf{Arr}}$, $\widehat{\mathsf{Map}}$) from \S\ref{app:semantics}
\item \textbf{Abstract stores:} $\hat{\sigma} \in \widehat{\Sigma} = \mathsf{Var} \rightharpoonup \widehat{\mathsf{Val}}$
\end{itemize}

\smallskip
\noindent\textbf{Auxiliary functions:}
\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt]
\item $\mathrm{refine}(\hat{\sigma},p,b)$: narrows operands of $p$ by interval meets
\item $\widehat{\mathrm{write}}(\hat{\sigma},\mathit{lv},\hat{v})$: strong update if singleton index/key, weak update otherwise
\item $\mathrm{joinRes}(r_1,r_2)$: componentwise join of abstract results
\end{itemize}

\begin{table}[h]
  \caption{Abstract semantics (denotational)}
  \label{tab:abs-denot}
  \centering
  \small
  \setlength{\tabcolsep}{6pt}
  \renewcommand{\arraystretch}{1.12}
  \begin{tabularx}{\columnwidth}{@{}l X@{}}
    \toprule
    \textbf{Statement} & \textbf{Meaning} \\
    \midrule
    \textsf{skip} &
    $\llbracket \textsf{skip}\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}(\hat{\sigma})$\\

    $s_1; s_2$ &
    $\llbracket s_1; s_2\rrbracket^\sharp(\hat{\sigma})=\big(\llbracket s_1\rrbracket^\sharp(\hat{\sigma})\big)\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\llbracket s_2\rrbracket^\sharp(\hat{\sigma}'))$\\

    $\tau\ x;$ &
    $\llbracket \tau\ x;\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\hat{\sigma}[x\mapsto \hat{\mathrm{init}}(\tau)]\big)$\\

    $\tau\ x=e;$ &
    $\llbracket \tau\ x=e;\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\hat{\sigma}[x\mapsto \alpha_\tau(\llbracket e\rrbracket^\sharp_{\hat{\sigma}})]\big)$\\

    $\mathit{lv}:=e$ &
    $\llbracket \mathit{lv}:=e\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\widehat{\mathrm{write}}(\hat{\sigma},\,\mathit{lv},\,\llbracket e\rrbracket^\sharp_{\hat{\sigma}})\big)$\\

    \textsf{delete}\ $\mathit{lv}$ &
    $\llbracket \textsf{delete}\ \mathit{lv}\rrbracket^\sharp(\hat{\sigma})=\widehat{\Norm}\!\big(\widehat{\mathrm{write}}(\hat{\sigma},\,\mathit{lv},\,\hat{\mathrm{zero}}_{\tau(\mathit{lv})})\big)$\\

    \textsf{if}\ $p$ \textsf{then}\ $s_t$ \textsf{else}\ $s_f$ &
    $\hat{\sigma}_t=\mathrm{refine}(\hat{\sigma},p,\mathsf{true})$, $\hat{\sigma}_f=\mathrm{refine}(\hat{\sigma},p,\mathsf{false})$;
    $\llbracket \cdot\rrbracket^\sharp(\hat{\sigma})=\mathrm{joinRes}\!\big(\llbracket s_t\rrbracket^\sharp(\hat{\sigma}_t),\ \llbracket s_f\rrbracket^\sharp(\hat{\sigma}_f)\big)$\\

    \textsf{while}\ $p$ \textsf{do}\ $s$ &
    $G^\sharp(H)(\hat{\sigma})=\mathrm{joinRes}\big(
      \llbracket s\rrbracket^\sharp(\mathrm{refine}(\hat{\sigma},p,\mathsf{true}))\ \triangleright^\sharp\ H,\;
      \widehat{\Norm}(\mathrm{refine}(\hat{\sigma},p,\mathsf{false}))
    \big)$;
    $\llbracket \textsf{while}\ p\ \textsf{do}\ s\rrbracket^\sharp = \mathrm{lfp}^{\nabla}(G^\sharp)$\\

    \textsf{for}\ $init$; $p$; $incr$ \textsf{do}\ $s$ &
    $G^\sharp(H)(\hat{\sigma})=\mathrm{joinRes}\big(
      \llbracket s\rrbracket^\sharp(\mathrm{refine}(\hat{\sigma},p,\mathsf{true}))\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\llbracket incr\rrbracket^\sharp(\hat{\sigma}')\ \triangleright^\sharp\ H),\;
      \widehat{\Norm}(\mathrm{refine}(\hat{\sigma},p,\mathsf{false}))
    \big)$;
    $\llbracket \textsf{for}\ init; p; incr\ \textsf{do}\ s\rrbracket^\sharp(\hat{\sigma})=
      \llbracket init\rrbracket^\sharp(\hat{\sigma})\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\mathrm{lfp}^{\nabla}(G^\sharp)(\hat{\sigma}'))$\\

    \textsf{do}\ $s$ \textsf{while}\ $p$ &
    $G^\sharp(H)(\hat{\sigma})=\llbracket s\rrbracket^\sharp(\hat{\sigma})\ \triangleright^\sharp\ (\lambda \hat{\sigma}'.\,\mathrm{joinRes}\big(
      H(\mathrm{refine}(\hat{\sigma}',p,\mathsf{true})),\;
      \widehat{\Norm}(\mathrm{refine}(\hat{\sigma}',p,\mathsf{false}))
    \big))$;
    $\llbracket \textsf{do}\ s\ \textsf{while}\ p\rrbracket^\sharp = \mathrm{lfp}^{\nabla}(G^\sharp)$\\

    \textsf{return}\ $e$ &
    $\llbracket \textsf{return}\ e\rrbracket^\sharp(\hat{\sigma})=\widehat{\Ret}(\llbracket e\rrbracket^\sharp_{\hat{\sigma}},\,\hat{\sigma})$\\

    \textsf{assert}$(p)$,\ \textsf{require}$(p)$ &
    $\widehat{\Norm}(\mathrm{refine}(\hat{\sigma},p,\mathsf{true}))$ if $p$ must-hold; $\widehat{\Abort}$ if $p$ must-fail; $\mathrm{joinRes}$ otherwise\\

    \textsf{revert}$(\cdots)$ &
    $\llbracket \textsf{revert}(\cdots)\rrbracket^\sharp(\hat{\sigma})=\widehat{\Abort}$\\

    \textsf{try}\ $e$ (\textsf{returns}\ $(x)$)\ $s_t$ \textsf{catch}\ $s_c$ &
    $\llbracket \cdot\rrbracket^\sharp(\hat{\sigma})=\mathrm{joinRes}\!\big(
      \llbracket s_t\rrbracket^\sharp(\hat{\sigma}[x\mapsto \top]),\
      \llbracket s_c\rrbracket^\sharp(\hat{\sigma})
    \big)$\\

    \textsf{call}$(\overline{e})$ &
    Internal: parameter binding; external: havoc footprint or $\widehat{\Abort}$\\
    \bottomrule
  \end{tabularx}
\end{table}

\end{document}
